/* DSblock model generated by Dymola from Modelica model Hotel.Hotel.CoolingTowerSection.CoolingTowerTest.TestwithConstant
 Dymola Version 2015 (32-bit), 2014-04-11 translated this at Thu Aug 14 15:11:36 2014

   */

#include <matrixop.h>
static double DymArrays0[1]={0.0};
static const char* DymArrays1[1]={"SimpleLiquidWater"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  RealArray   r_V_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(RealArray    eta_02, 
  RealArray    r_V_02) {
  struct DymStruc0 dummy_0;
  dummy_0.eta_0member = eta_02;
  dummy_0.r_V_0member = r_V_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 data0_0, double  rx_0V, RealArray   d0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC double   Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  kx_0der, double  mx_0flowx_0turbulentx_0der);
DYMOLA_STATIC double   Hotel_Buildings_Utilities_Math_Functions_spliceFunction(
  double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters data;
discrete input Real r_V(unit = "1") "Volumetric flow rate divided by nominal flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete output Real eta(unit = "1", min = 0.0) "Efficiency";
protected 
Integer n(start = size(data.r_V, 1)) "Number of data points";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := data.eta[1];
else
i := 1;
for j in (1:n-1) loop
if (r_V > data.r_V[j]) then 
i := j;
end if;
end for;
eta := Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(r_V, data.r_V[i], data.r_V[i+1], data.eta[i], data.eta[i+1], d[i], d[i+1]);
end if;
annotation(smoothOrder=1);
end Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc0 data0_0, double  rx_0V, RealArray   d0_0) {
  PushContext("Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( data0_0.r_V_0member, 1);
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealVectorElement( data0_0.eta_0member, (SizeType)(1));
      }
      else{
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rx_0V > RealElement( data0_0.r_V_0member, (SizeType)(j0_0_0))) {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
          (rx_0V, RealElement( data0_0.r_V_0member, (SizeType)(i0_0)), 
          RealElement( data0_0.r_V_0member, (SizeType)(i0_0+1)), RealElement( 
          data0_0.eta_0member, (SizeType)(i0_0)), RealElement( data0_0.
          eta_0member, (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)),
           RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(smoothOrder=1);
end Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real kSquInv(unit = "1/(kg.m)") "Flow coefficient";
public 
algorithm 
kSquInv := 1/k^2;
dp := Modelica.Fluid.Utilities.regSquare2(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1);
annotation(derivative=Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der, LateInline=true, smoothOrder=2);
end Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    dp0_0=0;
    kSquInv0_0=0;
    /* Start of real code */
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dp0_0 = Modelica_Fluid_Utilities_regSquare2(mx_0flow, mx_0flowx_0turbulent,
         kSquInv0_0, kSquInv0_0, false, 1);
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der
discrete input Real m_flow;
discrete input Real k;
discrete input Real m_flow_turbulent;
protected 
discrete Real dp;
discrete Real kSquInv;
public 
discrete input Real m_flow_der;
discrete input Real k_der;
discrete input Real m_flow_turbulent_der;
discrete output Real dp_der;
protected 
discrete Real kSquInv_der;
public 
algorithm 
kSquInv_der :=  -2.0*(k*k_der)/(k^2)^2;
kSquInv := 1/k^2;
dp_der := Modelica.Fluid.Utilities.regSquare2:der(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1, m_flow_der, m_flow_turbulent_der, kSquInv_der, kSquInv_der, 0);
annotation(smoothOrder=1);
end Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der;

  */
DYMOLA_STATIC double   Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  kx_0der, double  mx_0flowx_0turbulentx_0der) {
  PushContext("Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    double   dpx_0der;
    double   kSquInvx_0der;
    dp0_0=0;
    kSquInv0_0=0;
    dpx_0der=0;
    kSquInvx_0der=0;
    /* Start of real code */
      kSquInvx_0der =  -divmacro(2.0*k0_0*kx_0der,"2.0*(k*k_der)",sqr(sqr(k0_0)),
        "(k^2)^2");
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dpx_0der = Modelica_Fluid_Utilities_regSquare2__der(mx_0flow, 
        mx_0flowx_0turbulent, kSquInv0_0, kSquInv0_0, false, 1, mx_0flowx_0der, 
        mx_0flowx_0turbulentx_0der, kSquInvx_0der, kSquInvx_0der, 0);
    /* Output section */
    PopContext()
    return dpx_0der;
  }}

/* Flattened Modelica model:

function Hotel.Buildings.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=Hotel.Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end Hotel.Buildings.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   Hotel_Buildings_Utilities_Math_Functions_spliceFunction(
  double  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("Hotel.Buildings.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)(i0_0_0)), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)(i0_0_0))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
discrete input Real k2(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then k1*x^2 else (if x <=  -x_small then  -k2*x^2 else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN k10_0*sqr(x0_0) ELSE IF x0_0 <=  -
        xx_0small THEN  -k20_0*sqr(x0_0) ELSE IF k10_0 >= k20_0 THEN 
        Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(x0_0, xx_0small,
         k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
discrete input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
algorithm 
x2 :=  -x1;
if (x <= x2) then 
y :=  -k2*x^2;
else
y1 := k1*x1^2;
y2 :=  -k2*x2^2;
y1d := k1*2*x1;
y2d :=  -k2*2*x2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := 2.23606797749979*k1*x1;
w2 := 2.23606797749979*k2*abs(x2);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d := ww;
end if;
y := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x2, y2, y2d, y0d));
end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    /* Start of real code */
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        y0_0 =  -k20_0*sqr(x0_0);
      }
      else{
        y10_0 = k10_0*sqr(x10_0);
        y20_0 =  -k20_0*sqr(x20_0);
        y1d0_0 = k10_0*2*x10_0;
        y2d0_0 =  -k20_0*2*x20_0;
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0d0_0 = ww0_0;
        }
        y0_0 = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2:der
discrete input Real x;
discrete input Real x_small(start = 0.01);
discrete input Real k1(start = 1);
discrete input Real k2(start = 1);
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x_small_der(start = 0.0);
discrete input Real k1_der(start = 0);
discrete input Real k2_der(start = 0);
discrete input Real yd0_der(start = 0);
discrete output Real y_der;

algorithm 
y_der := smooth(1, (if x >= x_small then k1_der*x^2+2.0*(k1*(x*x_der)) else (if x <=  -x_small then  -(k2_der*x^2+2.0*(k2*(x*x_der))) else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der(x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, yd0_der) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der( -x, x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN k1x_0der*sqr(x0_0)+2.0*k10_0*x0_0*
        xx_0der ELSE IF x0_0 <=  -xx_0small THEN  -(k2x_0der*sqr(x0_0)+2.0*k20_0
        *x0_0*xx_0der) ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
discrete input Real x "Value for which polynomial shall be evaluated";
discrete input Real x1 "Abscissa value";
discrete input Real y1 "y1=f(x1)";
discrete input Real y1d "First derivative at y1";
discrete input Real y0d "First derivative at f(x=0)";
discrete output Real y;
protected 
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
algorithm 
a1 := x1*y0d;
a2 := 3*y1-x1*y1d-2*a1;
a3 := y1-a2-a1;
xx := x/x1;
y := xx*(a1+xx*(a2+xx*a3));
annotation(derivative=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der, smoothOrder=3);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    /* Start of real code */
      a10_0 = x10_0*y0d0_0;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a30_0 = y10_0-a20_0-a10_0;
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      y0_0 = xx0_0*(a10_0+xx0_0*(a20_0+xx0_0*a30_0));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der
discrete input Real x;
discrete input Real x1;
discrete input Real k1;
discrete input Real k2;
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real k1_der;
discrete input Real k2_der;
discrete input Real yd0_der(start = 0);
discrete output Real y_der;
protected 
discrete Real x2_der;
discrete Real y1_der;
discrete Real y2_der;
discrete Real y1d_der;
discrete Real y2d_der;
discrete Real w_der;
discrete Real w1_der;
discrete Real w2_der;
discrete Real y0d_der;
discrete Real ww_der;
public 
algorithm 
x2_der :=  -x1_der;
x2 :=  -x1;
if (x <= x2) then 
y_der :=  -(k2_der*x^2+2.0*(k2*(x*x_der)));
else
y1_der := k1_der*x1^2+2.0*(k1*(x1*x1_der));
y1 := k1*x1^2;
y2_der :=  -(k2_der*x2^2+2.0*(k2*(x2*x2_der)));
y2 :=  -k2*x2^2;
y1d_der := 2.0*(k1_der*x1+k1*x1_der);
y1d := 2.0*(k1*x1);
y2d_der := (-2.0)*(k2_der*x2+k2*x2_der);
y2d := (-2.0)*(k2*x2);
if (use_yd0) then 
y0d_der := yd0_der;
y0d := yd0;
else
w_der := x2_der/x1-x2*x1_der/x1^2;
w := x2/x1;
y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-((3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2.0*(x1*(1-w)))-2.0*(((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der))/(2.0*(x1*(1-w)))^2;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2.0*(x1*(1-w)));
end if;
w1_der := 2.23606797749979*(k1_der*x1+k1*x1_der);
w1 := 2.23606797749979*(k1*x1);
w2_der := 2.23606797749979*(k2_der*abs(x2)+k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))));
w2 := 2.23606797749979*(k2*abs(x2));
ww_der := 0.9*(if w1 < w2 then w1_der else w2_der);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d_der := ww_der;
y0d := ww;
end if;
y_der := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x1, y1, y1d, y0d, x_der, x1_der, y1_der, y1d_der, y0d_der) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x2, y2, y2d, y0d, x_der, x2_der, y2_der, y2d_der, y0d_der));
end if;
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    double   yx_0der;
    double   x2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   w1x_0der;
    double   w2x_0der;
    double   y0dx_0der;
    double   wwx_0der;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    yx_0der=0;
    x2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    y0dx_0der=0;
    wwx_0der=0;
    /* Start of real code */
      x2x_0der =  -x1x_0der;
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        yx_0der =  -(k2x_0der*sqr(x0_0)+2.0*k20_0*x0_0*xx_0der);
      }
      else{
        y1x_0der = k1x_0der*sqr(x10_0)+2.0*k10_0*x10_0*x1x_0der;
        y10_0 = k10_0*sqr(x10_0);
        y2x_0der =  -(k2x_0der*sqr(x20_0)+2.0*k20_0*x20_0*x2x_0der);
        y20_0 =  -k20_0*sqr(x20_0);
        y1dx_0der = 2.0*(k1x_0der*x10_0+k10_0*x1x_0der);
        y1d0_0 = 2.0*k10_0*x10_0;
        y2dx_0der = (-2.0)*(k2x_0der*x20_0+k20_0*x2x_0der);
        y2d0_0 = (-2.0)*k20_0*x20_0;
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1.0,"1.0",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1.0,"1.0",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2.0*x10_0*helpvar[8];
          helpvar[10] = divmacro(1.0,"1.0",helpvar[9],"2.0*(x1*(1-w))");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1.0,"1.0",helpvar[15],"(2.0*(x1*(1-w)))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2.0*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2.0*
            x10_0*(1-w0_0),"2.0*(x1*(1-w))");
        }
        w1x_0der = 2.23606797749979*(k1x_0der*x10_0+k10_0*x1x_0der);
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w2x_0der = 2.23606797749979*(k2x_0der*fabs(x20_0)+k20_0*x2x_0der*(IF 
          x20_0 > 0 THEN 1 ELSE -1));
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        wwx_0der = 0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0dx_0der = wwx_0der;
          y0d0_0 = ww0_0;
        }
        yx_0der = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0, xx_0der, x1x_0der, y1x_0der, 
          y1dx_0der, y0dx_0der) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0, xx_0der, x2x_0der, y2x_0der, 
          y2dx_0der, y0dx_0der);
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der
discrete input Real x;
discrete input Real x1;
discrete input Real y1;
discrete input Real y1d;
discrete input Real y0d;
protected 
discrete Real y;
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real y1_der;
discrete input Real y1d_der;
discrete input Real y0d_der;
discrete output Real y_der;
protected 
discrete Real a1_der;
discrete Real a2_der;
discrete Real a3_der;
discrete Real xx_der;
public 
algorithm 
a1_der := x1_der*y0d+x1*y0d_der;
a1 := x1*y0d;
a2_der := 3*y1_der-(x1_der*y1d+x1*y1d_der)-2*a1_der;
a2 := 3*y1-x1*y1d-2*a1;
a3_der := y1_der-a2_der-a1_der;
a3 := y1-a2-a1;
xx_der := x_der/x1-x*x1_der/x1^2;
xx := x/x1;
y_der := xx_der*(a1+xx*(a2+xx*a3))+xx*(a1_der+xx_der*(a2+xx*a3)+xx*(a2_der+xx_der*a3+xx*a3_der));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    double   yx_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   a3x_0der;
    double   xxx_0der;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    yx_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    a3x_0der=0;
    xxx_0der=0;
    /* Start of real code */
      a1x_0der = x1x_0der*y0d0_0+x10_0*y0dx_0der;
      a10_0 = x10_0*y0d0_0;
      a2x_0der = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der)-2*a1x_0der;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a3x_0der = y1x_0der-a2x_0der-a1x_0der;
      a30_0 = y10_0-a20_0-a10_0;
      xxx_0der = divmacro(xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,
        "x*x1_der",sqr(x10_0),"x1^2");
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      yx_0der = xxx_0der*(a10_0+xx0_0*(a20_0+xx0_0*a30_0))+xx0_0*(a1x_0der+
        xxx_0der*(a20_0+xx0_0*a30_0)+xx0_0*(a2x_0der+xxx_0der*a30_0+xx0_0*
        a3x_0der));
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
DYMOLA_STATIC const char*modelName="Hotel.Hotel.CoolingTowerSection.CoolingTowerTest.TestwithConstant";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/german/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[9]={3 , 3 , 1 , 3 , 4 , 1 , 2 , 1 , 5};
DYMOLA_STATIC long QJacobianGC_[16]={
1 , 1 , 3 , 4 , 4 , 0 , 2 , 2 , 2 , 2 , 0 , 0 , 5 , 5 , 5 , 0};
DYMOLA_STATIC double QJacobianCD_[6]={0  , 44 , 50 , 66 , 77 , 72};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = true;
W_[10] = 10;
W_[11] = 100;
W_[12] = 10;
W_[13] = 100;
W_[14] = 10;
W_[15] = 100;
W_[16] = 1;
W_[28] = 3;
W_[29] = false;
W_[30] = false;
W_[31] = false;
W_[32] = false;
W_[34] = true;
W_[38] = 10;
W_[40] = false;
W_[44] = 100;
W_[48] = 1;
W_[49] = 1;
W_[50] = 1;
W_[51] = 1;
W_[52] = 1;
W_[53] = 1;
W_[58] = 2;
W_[62] = false;
W_[66] = 1.0;
W_[71] = false;
W_[72] = true;
W_[74] = 10;
W_[76] = false;
W_[79] = 100;
W_[84] = 10;
W_[85] = 100;
W_[114] = 1;
W_[115] = 1;
W_[118] = true;
W_[121] = 10;
W_[123] = false;
W_[124] = 1;
W_[125] = 1;
W_[126] = 1;
W_[127] = 1;
W_[132] = 2;
W_[136] = true;
W_[144] = false;
W_[148] = true;
W_[149] = false;
W_[153] = true;
W_[160] = false;
W_[161] = true;
W_[167] = true;
W_[172] = true;
W_[175] = true;
W_[177] = 1;
W_[178] = 1;
W_[179] = 2;
W_[182] = 2;
W_[185] = 2;
W_[186] = 0;
W_[187] = 0;
W_[188] = 2;
W_[194] = true;
W_[213] = 1;
W_[227] = 3;
W_[228] = false;
W_[229] = false;
W_[230] = false;
W_[231] = false;
W_[235] = 1;
W_[246] = 3;
W_[247] = false;
W_[248] = false;
W_[249] = false;
W_[250] = false;
W_[252] = 1;
W_[253] = 1;
W_[254] = 1;
W_[259] = 2;
DYNSetAuxString("SimpleLiquidWater", 0);
W_[281] = 1;
W_[282] = 1;
W_[283] = 1;
W_[288] = 2;
W_[45] = false;
W_[176] = 4;
W_[1] = 1;
W_[2] = 1;
W_[3] = 1;
W_[4] = 1;
W_[5] = 4;
W_[8] = false;
W_[22] = false;
W_[23] = true;
W_[39] = 0.001;
W_[42] = true;
W_[43] = false;
W_[47] = true;
W_[57] = 10;
W_[59] = 0.001;
W_[60] = true;
W_[90] = 995.586;
W_[64] = 995.586;
W_[65] = 995.586;
W_[67] = 300000.0;
W_[68] = 293.15;
W_[75] = 0.001;
W_[78] = false;
W_[80] = true;
W_[81] = false;
W_[89] = true;
W_[86] = false;
W_[83] = 0.001;
W_[88] = 1.0;
W_[97] = false;
W_[98] = true;
W_[99] = 995.586;
W_[116] = 1;
W_[117] = 1;
W_[120] = false;
W_[122] = 0.001;
W_[131] = 10;
W_[133] = 0.001;
W_[134] = true;
W_[138] = 995.586;
W_[139] = 995.586;
W_[140] = 300000.0;
W_[141] = 293.15;
W_[155] = false;
W_[156] = false;
W_[159] = 0.001;
W_[174] = 300000.0;
W_[181] = 4;
W_[184] = 10;
W_[197] = 10;
W_[198] = 0.001;
W_[200] = 3;
W_[221] = false;
W_[222] = true;
W_[232] = 100;
W_[241] = false;
W_[242] = true;
W_[255] = 1;
W_[268] = true;
W_[269] = true;
W_[279] = 995.586;
W_[284] = 1;
W_[295] = true;
W_[296] = true;
W_[306] = 995.586;
W_[46] = 0.1;
W_[199] = 1;
W_[302] = 0.0;
W_[275] = 0.0;
W_[96] = 0;
W_[20] = 0;
W_[211] = 100;
W_[168] = 0;
W_[218] = 0;
W_[224] = 0.001;
W_[239] = 0;
W_[266] = 0;
W_[293] = 0;
W_[275] = 0.0;
W_[302] = 0.0;
W_[275] = 0.0;
W_[302] = 0.0;
W_[267] = 0.018015268;
W_[263] = 1.0;
W_[262] = 995.586;
W_[151] = 0.0;
W_[119] = 100.0;
W_[154] = 100.0;
W_[165] = 100.0;
W_[152] = 995.586;
W_[145] = 0.0;
W_[303] = 0.0;
W_[294] = 0.018015268;
W_[290] = 1.0;
W_[289] = 995.586;
W_[137] = 0.0;
W_[195] = 100.0;
W_[196] = 100.0;
W_[21] = 0.018015268;
W_[18] = 1.0;
W_[17] = 995.586;
W_[207] = 100.0;
W_[219] = 0.018015268;
W_[216] = 1.0;
W_[215] = 995.586;
W_[214] = 100.0;
W_[220] = 100.0;
W_[233] = 100.0;
W_[225] = 100.0;
W_[240] = 0.018015268;
W_[237] = 1.0;
W_[236] = 995.586;
BoundParameterSection
AssertModelica(DP_[7] >= 0.0,"CooTow.CooTowSys.bou.p >= 0.0", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(
  DP_[7], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),"\" is negative\n(Temperature = "),
  Real2String2(DP_[8], true, 0))," K)"));
PopAllMarks();
AssertModelica(DP_[8] >= 272.15 AND DP_[8] <= 403.15,"CooTow.CooTowSys.bou.T >= 272.15 and CooTow.CooTowSys.bou.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DP_[8], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(DP_[48] > 0,"CooTow.CooTowSys.Pum.filter.A_ripple > 0", 
  "A_ripple > 0 required");
AssertModelica(DP_[58] >= 272.15 AND DP_[58] <= 403.15,"bou1.T >= 272.15 and bou1.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DP_[58], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(DP_[7] >= 0.0,"CooTow.CooTowSys.bou.p >= 0.0", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(
  DP_[7], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),"\" is negative\n(Temperature = "),
  Real2String2(DP_[62], true, 0))," K)"));
PopAllMarks();
AssertModelica(DP_[62] >= 272.15 AND DP_[62] <= 403.15,"boundary.T >= 272.15 and boundary.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DP_[62], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[54] = DP_[14];
W_[55] = DP_[15];
W_[56] = DP_[16];
W_[61] = divmacro(10*DP_[13],"10*CooTow.CooTowSys.CooTow.tau",W_[90],
  "CooTow.CooTowSys.CooTow.rho_default");
W_[69] = W_[54];
W_[70] = W_[55];
W_[87] = W_[46];
W_[82] = IF W_[89] AND W_[86] THEN 0.7853981633974483*W_[83]*DP_[23]*DP_[24]
   ELSE IF W_[89] THEN 10*W_[87] ELSE 0;
W_[91] = DP_[14];
W_[92] = DP_[15];
W_[93] = 4184*(W_[92]-273.15);
W_[128] = DP_[35];
W_[129] = DP_[36];
W_[130] = DP_[37];
W_[146] = DP_[41];
W_[147] = divmacro(W_[131]*W_[146],"CooTow.CooTowSys.Pum.vol.m_flow_nominal*CooTow.CooTowSys.Pum.vol.tau",
  W_[138],"CooTow.CooTowSys.Pum.vol.rho_default");
W_[135] = W_[147];
W_[142] = W_[128];
W_[143] = W_[129];
W_[157] = 0.01*W_[6];
W_[158] = DP_[46];
W_[169] = DP_[35];
W_[170] = DP_[36];
W_[171] = 4184*(W_[170]-273.15);
W_[180] = divmacro(5,"5",6.283185307179586*DP_[45],"6.283185307179586*CooTow.CooTowSys.Pum.riseTime");
W_[183] = DP_[46];
W_[202] = W_[199] > 1E-010 OR W_[199] < -1E-010;
W_[256] = W_[54];
W_[257] = W_[55];
W_[258] = W_[56];
W_[280] = 4184*(W_[257]-273.15);
W_[285] = W_[128];
W_[286] = W_[129];
W_[287] = W_[130];
W_[307] = 4184*(W_[286]-273.15);
W_[193] = 0.1*DP_[60];
W_[245] = 4184*(DP_[62]-273.15);
Aux_[8] = W_[245];
W_[27] = 4184*(DP_[8]-273.15);
W_[274] = 995.586*W_[61];
W_[226] = 4184*(DP_[58]-273.15);
Aux_[12] = W_[226];
W_[301] = 995.586*W_[135];
W_[206] = 273.15+0.0002390057361376673*W_[226];
W_[33] = DP_[9];
W_[234] = DP_[59];
W_[251] = DP_[63];
Aux_[5] = W_[226];
Aux_[6] = W_[226];
Aux_[7] = W_[226];
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
W_[19] = 4184*(DP_[8]-273.15);
W_[24] = DP_[8]-273.15;
W_[25] = 1E-005*DP_[7];
W_[166] = 273.15+0.0002390057361376673*Aux_[5];
W_[217] = 4184*(DP_[58]-273.15);
W_[223] = DP_[58]-273.15;
W_[238] = 4184*(DP_[62]-273.15);
W_[243] = DP_[62]-273.15;
W_[244] = 1E-005*DP_[7];
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[35] = 0;
W_[37] = -10;
W_[41] = 0;
W_[77] = 0;
W_[94] = 288.15;
W_[107] = -100;
W_[150] = 288.15;
W_[164] = 300;
W_[173] = 1;
W_[201] = 1;
W_[205] = 300;
W_[260] = 300000.0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[36] = W_[93];
W_[73] = W_[93];
W_[162] = W_[157];
W_[204] = DP_[56];
W_[209] =  -W_[158];
W_[212] = W_[171];
W_[272] = 4165531.824*W_[61]*(W_[70]-273.15);
W_[299] = 4165531.824*W_[135]*(W_[143]-273.15);
InitialStartSection
Aux_[1] = W_[93];
Aux_[1] = W_[93];
InitialStartSection2
X_[2] = DP_[56];
X_[3] = W_[257];
X_[4] = W_[286];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
F_[0] = 0.0;
W_[110] = 1.0044335697769957E-005;
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[54] = DP_[14];
W_[55] = DP_[15];
W_[56] = DP_[16];
W_[61] = divmacro(10*DP_[13],"10*CooTow.CooTowSys.CooTow.tau",W_[90],
  "CooTow.CooTowSys.CooTow.rho_default");
W_[69] = W_[54];
W_[70] = W_[55];
W_[87] = W_[46];
W_[82] = IF W_[89] AND W_[86] THEN 0.7853981633974483*W_[83]*DP_[23]*DP_[24]
   ELSE IF W_[89] THEN 10*W_[87] ELSE 0;
W_[91] = DP_[14];
W_[92] = DP_[15];
W_[93] = 4184*(W_[92]-273.15);
W_[128] = DP_[35];
W_[129] = DP_[36];
W_[130] = DP_[37];
W_[146] = DP_[41];
W_[147] = divmacro(W_[131]*W_[146],"CooTow.CooTowSys.Pum.vol.m_flow_nominal*CooTow.CooTowSys.Pum.vol.tau",
  W_[138],"CooTow.CooTowSys.Pum.vol.rho_default");
W_[135] = W_[147];
W_[142] = W_[128];
W_[143] = W_[129];
W_[157] = 0.01*W_[6];
W_[158] = DP_[46];
W_[169] = DP_[35];
W_[170] = DP_[36];
W_[171] = 4184*(W_[170]-273.15);
W_[180] = divmacro(5,"5",6.283185307179586*DP_[45],"6.283185307179586*CooTow.CooTowSys.Pum.riseTime");
AssertModelica(W_[180] > 0,"CooTow.CooTowSys.Pum.filter.f_cut > 0", 
  "f_cut > 0 required");
W_[183] = DP_[46];
W_[256] = W_[54];
W_[257] = W_[55];
W_[258] = W_[56];
W_[280] = 4184*(W_[257]-273.15);
W_[285] = W_[128];
W_[286] = W_[129];
W_[287] = W_[130];
W_[307] = 4184*(W_[286]-273.15);
W_[202] = W_[199] > 1E-010 OR W_[199] < -1E-010;
W_[109] = 0.010044335697769956;
  RealAssign (RealTemporaryDense( &W_[111], 1, 1), RealTemporaryDense( DymArrays0,
     1, 1));
  PopAllMarks();
  RealAssign (RealTemporaryDense( &W_[112], 1, 1), RealTemporaryDense( DymArrays0,
     1, 1));
  PopAllMarks();
RealAssign (RealTemporaryDense( &W_[189], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, CooTow.CooTowSys.Pum.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[50])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(CooTow.CooTowSys.Pum.filter.cr, CooTow.CooTowSys.Pum.filter.c0, CooTow.CooTowSys.Pum.filter.c1, CooTow.CooTowSys.Pum.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[189], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[180]));
  RealAssign (RealTemporaryDense( &W_[191], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
W_[193] = 0.1*DP_[60];
W_[245] = 4184*(DP_[62]-273.15);
InitialSection
Aux_[8] = W_[245];
InitialSection2
W_[27] = 4184*(DP_[8]-273.15);
W_[274] = 995.586*W_[61];
W_[226] = 4184*(DP_[58]-273.15);
InitialSection
Aux_[12] = W_[226];
InitialSection2
W_[301] = 995.586*W_[135];
W_[206] = 273.15+0.0002390057361376673*W_[226];
W_[33] = DP_[9];
W_[234] = DP_[59];
W_[251] = DP_[63];
InitialSection
Aux_[5] = W_[226];
Aux_[6] = W_[226];
Aux_[7] = W_[226];
InitialSection2
W_[19] = 4184*(DP_[8]-273.15);
W_[24] = DP_[8]-273.15;
W_[25] = 1E-005*DP_[7];
W_[166] = 273.15+0.0002390057361376673*Aux_[5];
W_[217] = 4184*(DP_[58]-273.15);
W_[223] = DP_[58]-273.15;
W_[238] = 4184*(DP_[62]-273.15);
W_[243] = DP_[62]-273.15;
W_[244] = 1E-005*DP_[7];
 /* Linear system of equations to solve. */
X_[0] = 0.0;
SolveScalarLinearParametric( -W_[191]," -CooTow.CooTowSys.Pum.filter.r[1]",  -
  W_[191]*W_[193]," -CooTow.CooTowSys.Pum.filter.r[1]*CooTow.CooTowSys.Pum.filter.uu[1]",
   X_[0],"CooTow.CooTowSys.Pum.filter.x[1]");
 /* End of Equation Block */ 

W_[209] =  -W_[183];
 /* Linear system of equations to solve. */
X_[1] = 0.0;
SolveScalarLinearParametric(10.0*DP_[47],"10.0*CooTow.CooTowSys.Pum.filter.gain",
    -W_[209]," -CooTow.port_b1.m_flow", X_[1],"CooTow.CooTowSys.Pum.filter.x[2]");
 /* End of Equation Block */ 

X_[4] = W_[286];
AssertModelica(GreaterEqual(X_[4],"CooTow.CooTowSys.Pum.vol.dynBal.medium.T", 
  272.15,"272.15", 0) AND LessEqual(X_[4],"CooTow.CooTowSys.Pum.vol.dynBal.medium.T",
   403.15,"403.15", 1),"CooTow.CooTowSys.Pum.vol.dynBal.medium.T >= 272.15 and CooTow.CooTowSys.Pum.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[4], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
X_[3] = W_[257];
AssertModelica(GreaterEqual(X_[3],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T",
   272.15,"272.15", 2) AND LessEqual(X_[3],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T",
   403.15,"403.15", 3),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T >= 272.15 and CooTow.CooTowSys.CooTow.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[3], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
X_[2] = DP_[56];
F_[1] = W_[192]*(X_[1]-X_[0]);
W_[37] = DP_[40]+W_[209];
W_[35] =  -(DP_[17]+W_[37]);
W_[77] = homotopy((PushModelContext(1,"Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(CooTow.CooTowSys.CooTow.port_a.m_flow, 1.0, 1.0)")
  Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  W_[35], 1.0, 1.0)), 10.0*W_[35]);
PopModelContext();
W_[260] = DP_[7]-W_[77];
AssertModelica(GreaterEqual(W_[260],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p",
   0.0,"0.0", 4),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[260], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(X_[3], true, 0))," K)"));
PopAllMarks();
AssertModelica(GreaterEqual(W_[260],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p",
   0.0,"0.0", 4),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[260], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(X_[4], true, 0))," K)"));
PopAllMarks();
W_[210] = (-10.0)*DP_[47]*F_[1];
W_[261] =  -homotopy((PushModelContext(1,"Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(CooTow.CooTowSys.CooTow.port_a.m_flow, 1.0, 1.0,  -der(CooTow.port_b1.m_flow), 0.0, 0.0)")
  Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (W_[35], 1.0, 1.0,  -W_[210], 0.0, 0.0)), (-10.0)*W_[210]);
PopModelContext();
W_[107] = 100.0-W_[260];
W_[108] = (-0.0010044335697769957)*W_[209];
W_[102] = W_[107]*W_[108];
W_[173] = 99.5586*W_[108];
W_[105] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nCooTow.CooTowSys.Pum.hydraulicEfficiency, \nCooTow.CooTowSys.Pum.r_V, \nCooTow.CooTowSys.Pum.hydDer)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[34], 1, 1), RealTemporaryDense( &DP_[33], 1, 1)), 
  W_[173], RealTemporaryDense( &W_[112], 1, 1)));
PopAllMarks();
W_[106] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nCooTow.CooTowSys.Pum.motorEfficiency, \nCooTow.CooTowSys.Pum.r_V, \nCooTow.CooTowSys.Pum.motDer)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[32], 1, 1), RealTemporaryDense( &DP_[31], 1, 1)), 
  W_[173], RealTemporaryDense( &W_[111], 1, 1)));
PopAllMarks();
W_[104] = W_[105]*W_[106];
W_[100] = divmacro(W_[102],"CooTow.CooTowSys.Pum.WFlo",(PushModelContext(1,
  "Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.eta, 1E-005, CooTow.CooTowSys.Pum.eta-1E-005, 1E-006)")
  Hotel_Buildings_Utilities_Math_Functions_spliceFunction(W_[104], 1E-005, 
  W_[104]-1E-005, 1E-006)),"Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.eta, 1E-005, CooTow.CooTowSys.Pum.eta-1E-005, 1E-006)");
PopModelContext();
 /* Linear system of equations to solve. */
W_[101] = 0.0;
SolveScalarLinear(W_[105],"CooTow.CooTowSys.Pum.etaHyd", W_[102],
  "CooTow.CooTowSys.Pum.WFlo", W_[101],"CooTow.CooTowSys.Pum.WHyd");
 /* End of Equation Block */ 

W_[113] = (IF DP_[30] THEN W_[100] ELSE W_[101])-W_[102];
W_[103] = homotopy((PushModelContext(1,"Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.QThe_flow, 0, noEvent(abs(CooTow.CooTowSys.Pum.VMachine_flow))-2.0088671395539914E-005, 1.0044335697769957E-005)")
  Hotel_Buildings_Utilities_Math_Functions_spliceFunction(W_[113], 0, fabs(
  W_[108])-2.0088671395539914E-005, 1.0044335697769957E-005)), 0);
PopModelContext();
InitialSection
Init=false;InitializeData(2);Init=true;
InitialSection2
  AssertModelica(DP_[13] > 1E-015,"CooTow.CooTowSys.CooTow.tau > 1E-015", 
    StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DP_[13], true, 0)),"\n"));
  PopAllMarks();
  AssertModelica(DP_[13] > 1E-015,"CooTow.CooTowSys.CooTow.tau > 1E-015", 
    StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.          \n You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DP_[13], true, 0)),"\n"));
  PopAllMarks();
EndInitialSection

OutputSection
AssertModelica(GreaterEqual(X_[3],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T",
   272.15,"272.15", 2) AND LessEqual(X_[3],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T",
   403.15,"403.15", 3),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.T >= 272.15 and CooTow.CooTowSys.CooTow.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[3], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(GreaterEqual(X_[4],"CooTow.CooTowSys.Pum.vol.dynBal.medium.T", 
  272.15,"272.15", 0) AND LessEqual(X_[4],"CooTow.CooTowSys.Pum.vol.dynBal.medium.T",
   403.15,"403.15", 1),"CooTow.CooTowSys.Pum.vol.dynBal.medium.T >= 272.15 and CooTow.CooTowSys.Pum.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[4], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, CooTow.CooTowSys.bou.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays1, 1, 1), true, true, RealTemporaryDense( &W_[33], 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, bou1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays1, 1, 1), true, true, RealTemporaryDense( &W_[234], 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, boundary.X_in_internal, \"MassFlowSource_T\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays1, 1, 1), true, true, RealTemporaryDense( &W_[251], 1, 1), 
  "MassFlowSource_T"));
PopAllMarks();

DynamicsSection
F_[0] = W_[191]*(X_[0]-W_[193]);
F_[1] = W_[192]*(X_[1]-X_[0]);
W_[209] = (-10.0)*DP_[47]*X_[1];
W_[37] = DP_[40]+W_[209];
W_[36] = 4184*(X_[3]-273.15);
W_[212] = 4184*(X_[4]-273.15);
W_[304] =  -W_[37]*(IF  -W_[37] > 0.0 THEN W_[36] ELSE W_[212]);
W_[305] = W_[209]*(IF W_[209] > 0.0 THEN Aux_[12] ELSE W_[212]);
W_[300] = W_[304]+W_[305];
 /* Linear system of equations to solve. */
W_[292] = RememberSimple_(W_[292], 0);
SolveScalarLinearParametric( -W_[301]," -CooTow.CooTowSys.Pum.vol.dynBal.m",  -
  W_[300]," -der(CooTow.CooTowSys.Pum.vol.dynBal.U)", W_[292],"der(CooTow.CooTowSys.Pum.vol.dynBal.medium.u)");
 /* End of Equation Block */ 

F_[4] = 0.0002390057361376673*W_[292];
W_[35] =  -(DP_[17]+W_[37]);
W_[26] = DP_[61]-W_[35];
if (NewParameters) {
helpvar[0] = RealBmax(DP_[61], 0.0);
}
helpvar[1] = RealBmax( -W_[26], 0.0);
Aux_[13] = helpvar[0]+helpvar[1];
Aux_[14] = IF Aux_[13] > 1E-010 THEN 1.0 ELSE IF Aux_[13] > 0.0 THEN sqr(
  10000000000.0*Aux_[13])*(3.0-20000000000.0*Aux_[13]) ELSE 0.0;
helpvar[2] = 1.0-Aux_[14];
helpvar[3] = 1E-010*helpvar[2];
helpvar[4] = Aux_[14]*helpvar[0]+helpvar[3];
helpvar[5] = Aux_[14]*helpvar[1]+helpvar[3];
helpvar[6] = helpvar[4]+helpvar[5];
helpvar[7] = divmacro(1.0,"1.0",helpvar[6],"stream_alpha1*max(boundary.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -CooTow.CooTowSys.bou.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
W_[73] = helpvar[7]*(helpvar[4]*Aux_[8]+helpvar[5]*W_[27]);
W_[277] = W_[35]*(IF W_[35] > 0.0 THEN W_[73] ELSE W_[36]);
W_[278] = W_[37]*(IF W_[37] > 0.0 THEN W_[212] ELSE W_[36]);
W_[276] = W_[277]+W_[278];
W_[95] = W_[35]*(4184*(DP_[57]+DP_[29]-273.15)-W_[73]);
W_[94] = 273.15+0.0002390057361376673*W_[36];
W_[63] = W_[95]*(1+DP_[28]*(W_[94]-DP_[27]));
W_[273] = W_[276]+W_[63];
 /* Linear system of equations to solve. */
W_[265] = RememberSimple_(W_[265], 1);
SolveScalarLinearParametric( -W_[274]," -CooTow.CooTowSys.CooTow.vol.dynBal.m", 
   -W_[273]," -der(CooTow.CooTowSys.CooTow.vol.dynBal.U)", W_[265],
  "der(CooTow.CooTowSys.CooTow.vol.dynBal.medium.u)");
 /* End of Equation Block */ 

F_[3] = 0.0002390057361376673*W_[265];
W_[205] = 273.15+0.0002390057361376673*W_[212];
W_[204] = IF  -W_[209] > 0.001 THEN W_[205] ELSE IF  -W_[209] < -0.001 THEN 
  W_[206] ELSE 0.5*(W_[205]+W_[206])-250.0*W_[209]*(sqr((-1000.0)*W_[209])-3)*(
  W_[206]-W_[205]);
W_[203] = (-0.1)*W_[209];
W_[201] = IF  -W_[209] > 0.001 THEN W_[203] ELSE IF  -W_[209] < -0.001 THEN  -
  W_[203] ELSE 500.0*W_[209]*(sqr((-1000.0)*W_[209])-3)*W_[203];
F_[2] = (W_[204]-X_[2])*W_[201];

AcceptedSection1
W_[77] = (PushModelContext(1,"Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(CooTow.CooTowSys.CooTow.port_a.m_flow, 1.0, 1.0)")
  Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  W_[35], 1.0, 1.0));
PopModelContext();
W_[260] = DP_[7]-W_[77];
AssertModelica(GreaterEqual(W_[260],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p",
   0.0,"0.0", 4),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[260], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(X_[3], true, 0))," K)"));
PopAllMarks();
AssertModelica(GreaterEqual(W_[260],"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p",
   0.0,"0.0", 4),"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[260], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(X_[4], true, 0))," K)"));
PopAllMarks();

AcceptedSection2
Aux_[1] = W_[73];
Aux_[9] = W_[73];
Aux_[11] = W_[36];
Aux_[10] = W_[212];
helpvar[8] = RealBmax( -W_[35], 0.0);
Aux_[15] = helpvar[8]+helpvar[0];
Aux_[16] = IF Aux_[15] > 1E-010 THEN 1.0 ELSE IF Aux_[15] > 0.0 THEN sqr(
  10000000000.0*Aux_[15])*(3.0-20000000000.0*Aux_[15]) ELSE 0.0;
helpvar[9] = 1.0-Aux_[16];
helpvar[10] = 1E-010*helpvar[9];
helpvar[11] = Aux_[16]*helpvar[8]+helpvar[10];
helpvar[12] = Aux_[16]*helpvar[0]+helpvar[10];
helpvar[13] = helpvar[11]+helpvar[12];
helpvar[14] = divmacro(1.0,"1.0",helpvar[13],"stream_alpha3*max( -CooTow.CooTowSys.CooTow.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max(boundary.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
Aux_[0] = helpvar[14]*(helpvar[11]*W_[36]+helpvar[12]*Aux_[8]);
Aux_[2] = W_[212];
Aux_[3] = W_[73];
Aux_[4] = W_[36];
W_[264] = 4184*(X_[3]-273.15);
W_[272] = W_[274]*W_[264];
W_[291] = 4184*(X_[4]-273.15);
W_[299] = W_[301]*W_[291];
W_[210] = (-10.0)*DP_[47]*F_[1];
helpvar[15] = (PushModelContext(1,"Hotel.Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(CooTow.CooTowSys.CooTow.port_a.m_flow, 1.0, 1.0,  -der(CooTow.port_b1.m_flow), 0.0, 0.0)")
  Hotel_Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (W_[35], 1.0, 1.0,  -W_[210], 0.0, 0.0));
PopModelContext();
W_[261] =  -helpvar[15];
W_[41] = DP_[7]-W_[260];
W_[107] = 100.0-W_[260];
W_[108] = (-0.0010044335697769957)*W_[209];
W_[102] = W_[107]*W_[108];
W_[173] = divmacro(W_[108],"CooTow.CooTowSys.Pum.VMachine_flow",W_[109],
  "CooTow.CooTowSys.Pum.V_flow_max");
W_[105] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nCooTow.CooTowSys.Pum.hydraulicEfficiency, \nCooTow.CooTowSys.Pum.r_V, \nCooTow.CooTowSys.Pum.hydDer)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[34], 1, 1), RealTemporaryDense( &DP_[33], 1, 1)), 
  W_[173], RealTemporaryDense( &W_[112], 1, 1)));
PopAllMarks();
W_[106] = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\nCooTow.CooTowSys.Pum.motorEfficiency, \nCooTow.CooTowSys.Pum.r_V, \nCooTow.CooTowSys.Pum.motDer)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc0_construct(
  RealTemporaryDense( &DP_[32], 1, 1), RealTemporaryDense( &DP_[31], 1, 1)), 
  W_[173], RealTemporaryDense( &W_[111], 1, 1)));
PopAllMarks();
W_[104] = W_[105]*W_[106];
helpvar[16] = (PushModelContext(1,"Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.eta, 1E-005, CooTow.CooTowSys.Pum.eta-1E-005, 1E-006)")
  Hotel_Buildings_Utilities_Math_Functions_spliceFunction(W_[104], 1E-005, 
  W_[104]-1E-005, 1E-006));
PopModelContext();
helpvar[17] = divmacro(1.0,"1.0",helpvar[16],"Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.eta, 1E-005, CooTow.CooTowSys.Pum.eta-1E-005, 1E-006)");
W_[100] = helpvar[17]*W_[102];
 /* Linear system of equations to solve. */
W_[101] = RememberSimple_(W_[101], 2);
SolveScalarLinear(W_[105],"CooTow.CooTowSys.Pum.etaHyd", W_[102],
  "CooTow.CooTowSys.Pum.WFlo", W_[101],"CooTow.CooTowSys.Pum.WHyd");
 /* End of Equation Block */ 

W_[113] = (IF DP_[30] THEN W_[100] ELSE W_[101])-W_[102];
helpvar[18] = fabs(W_[108]);
W_[103] = (PushModelContext(1,"Hotel.Buildings.Utilities.Math.Functions.spliceFunction(CooTow.CooTowSys.Pum.QThe_flow, 0, noEvent(abs(CooTow.CooTowSys.Pum.VMachine_flow))-2*CooTow.CooTowSys.Pum.delta_V_flow, CooTow.CooTowSys.Pum.delta_V_flow)")
  Hotel_Buildings_Utilities_Math_Functions_spliceFunction(W_[113], 0, helpvar[18]
  -2*W_[110], W_[110]));
PopModelContext();
W_[150] = 273.15+0.0002390057361376673*W_[212];
W_[162] = W_[260]-100.0;
W_[163] = (-0.0010044335697769957)*W_[209];
W_[164] = 273.15+0.0002390057361376673*W_[212];
Aux_[17] = helpvar[8]+helpvar[1];
Aux_[18] = IF Aux_[17] > 1E-010 THEN 1.0 ELSE IF Aux_[17] > 0.0 THEN sqr(
  10000000000.0*Aux_[17])*(3.0-20000000000.0*Aux_[17]) ELSE 0.0;
helpvar[19] = 1.0-Aux_[18];
helpvar[20] = 1E-010*helpvar[19];
helpvar[21] = Aux_[18]*helpvar[8]+helpvar[20];
helpvar[22] = Aux_[18]*helpvar[1]+helpvar[20];
helpvar[23] = helpvar[21]+helpvar[22];
helpvar[24] = divmacro(1.0,"1.0",helpvar[23],"stream_alpha5*max( -CooTow.CooTowSys.CooTow.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)+stream_alpha5*max( -CooTow.CooTowSys.bou.ports[1].m_flow, 0.0)+1E-010*(1.0-stream_alpha5)");
W_[208] = helpvar[24]*(helpvar[21]*W_[36]+helpvar[22]*W_[27]);
W_[270] = X_[3]-273.15;
W_[271] = 1E-005*W_[260];
W_[297] = X_[4]-273.15;
W_[298] = 1E-005*W_[260];

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
283.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", \
0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal",\
 4, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 5, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 6, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("dp_nominal", "Nominal pressure difference [Pa|bar]", 100, \
0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.dp_nominal", "Nominal pressure difference [Pa|bar]", 100,\
 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.dp_nominal", "Nominal pressure difference [Pa|bar]",\
 100, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.bou.nPorts", "Number of ports [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("CooTow.CooTowSys.bou.medium.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 0)
DeclareAlias2("CooTow.CooTowSys.bou.medium.h", "Specific enthalpy of medium [J/kg]",\
 "CooTow.CooTowSys.bou.ports[1].h_outflow", 1, 5, 27, 0)
DeclareVariable("CooTow.CooTowSys.bou.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,513)
DeclareAlias2("CooTow.CooTowSys.bou.medium.T", "Temperature of medium [K|degC]",\
 "CooTow.CooTowSys.bou.T", 1, 7, 8, 0)
DeclareVariable("CooTow.CooTowSys.bou.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("CooTow.CooTowSys.bou.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("CooTow.CooTowSys.bou.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("CooTow.CooTowSys.bou.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("CooTow.CooTowSys.bou.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 0)
DeclareAlias2("CooTow.CooTowSys.bou.medium.state.T", "Temperature of medium [K|degC]",\
 "CooTow.CooTowSys.bou.T", 1, 7, 8, 0)
DeclareVariable("CooTow.CooTowSys.bou.medium.preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.bou.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.bou.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.bou.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.bou.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -1E+060,1E+060,0.0,0,776)
DeclareAlias2("CooTow.CooTowSys.bou.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareVariable("CooTow.CooTowSys.bou.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("CooTow.CooTowSys.bou.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.bou.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("CooTow.CooTowSys.bou.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("CooTow.CooTowSys.bou.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("CooTow.CooTowSys.bou.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("CooTow.CooTowSys.bou.p", "Fixed value of pressure [Pa|bar]", 7,\
 300000.0, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("CooTow.CooTowSys.bou.T", "Fixed value of temperature [K|degC]",\
 8, 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("CooTow.CooTowSys.bou.X[1]", "Fixed value of composition [kg/kg]",\
 9, 1.0, 0.0,1.0,0.1,0,560)
DeclareAlias2("CooTow.CooTowSys.bou.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 1024)
DeclareAlias2("CooTow.CooTowSys.bou.T_in_internal", "Needed to connect to conditional connector [K]",\
 "CooTow.CooTowSys.bou.T", 1, 7, 8, 1024)
DeclareVariable("CooTow.CooTowSys.bou.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,10.0,0,776)
DeclareAlias2("CooTow.CooTowSys.CooTow.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareVariable("CooTow.CooTowSys.CooTow.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("CooTow.CooTowSys.CooTow.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -10, -100000.0,100000.0,0.0,0,776)
DeclareAlias2("CooTow.CooTowSys.CooTow.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 4)
DeclareParameter("CooTow.CooTowSys.CooTow.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.CooTow.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.CooTow.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 12, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.CooTow.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.CooTow.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_a.m_flow", 1, 5, 35, 0)
DeclareVariable("CooTow.CooTowSys.CooTow.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.CooTow.computeFlowResistance", \
"=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.dp_nominal", "Pressure [Pa|Pa]", 100, \
0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.linearizeFlowResistance", \
"= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareParameter("CooTow.CooTowSys.CooTow.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 13, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("CooTow.CooTowSys.CooTow.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("CooTow.CooTowSys.CooTow.p_start", "Start value of pressure [Pa|bar]",\
 14, 300000.0, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("CooTow.CooTowSys.CooTow.T_start", "Start value of temperature [K|degC]",\
 15, 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("CooTow.CooTowSys.CooTow.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 16, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.substanceDynamics", \
"Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, \
1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.allowFlowReversal", \
"= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_a.m_flow", 1, 5, 35, 132)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_b.m_flow", 1, 5, 37, 132)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.heatPort.T", "Port temperature [K|degC]",\
 "CooTow.CooTowSys.CooTow.TLvg", 1, 5, 94, 4)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.T", "Temperature of the fluid [K|degC]",\
 "CooTow.CooTowSys.CooTow.TLvg", 1, 5, 94, 0)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.p", "Pressure of the fluid [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 0)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1.0,\
 0.0,1.0,0.1,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.state_start.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.useSteadyStateTwoPort", \
"Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.QSen_flow.y", "Value of Real output [W]",\
 "CooTow.CooTowSys.CooTow.vol.heatPort.Q_flow", 1, 5, 63, 1024)
DeclareParameter("CooTow.CooTowSys.CooTow.vol.masExc.k", "Constant output value [kg/s]",\
 17, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.masExc.y", "Connector of Real output signal [kg/s]",\
 "CooTow.CooTowSys.CooTow.vol.masExc.k", 1, 7, 17, 1024)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_a.m_flow", 1, 5, 35, 132)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.port_a.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 4)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_a.m_flow", -1, 5, 35, 132)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.port_b.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 18, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 19,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 20, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 10, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.CooTow.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_a.m_flow", 1, 5, 35, 0)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,100.0,0,512)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 100, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.m_flow_turbulent", \
"Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]", 1.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.sta_default.p", \
"Absolute pressure of medium [Pa|bar]", 21, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.sta_default.T", \
"Temperature of medium [K|degC]", 22, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.m_flow_nominal_pos", \
"Absolute value of nominal flow rate [kg/s]", 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.dp_nominal_pos", \
"Absolute value of nominal pressure [Pa|bar]", 100, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.dh", "Hydraulic diameter [m]", 23,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("CooTow.CooTowSys.CooTow.preDro.ReC", "Reynolds number where transition to turbulent starts",\
 24, 4000, 0.0,1E+100,0.0,0,560)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.1, 0.01,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.CooTow.preDro.computeFlowResistance", \
"Flag to enable/disable computation of flow resistance [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,2563)
DeclareParameter("CooTow.CooTowSys.CooTow.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 25, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("CooTow.CooTowSys.CooTow.sta_default.T", "Temperature of medium [K|degC]",\
 26, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("CooTow.CooTowSys.CooTow.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.sta_start.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.TLvg", "Leaving water temperature [K]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("CooTow.CooTowSys.CooTow.Q_flow", "Heat input into water circuit [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("CooTow.CooTowSys.CooTow.TAppAct", "Actual approach temperature [K,K]",\
 "CooTow.CooTowSys.CooTow.TApp", 1, 7, 29, 0)
DeclareAlias2("CooTow.CooTowSys.CooTow.TAirHT", "Air temperature that is used to compute the heat transfer with the water [K|degC]",\
 "CooTow.TWea.k", 1, 7, 57, 1024)
DeclareParameter("CooTow.CooTowSys.CooTow.preHea.T_ref", "Reference temperature [K|degC]",\
 27, 293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("CooTow.CooTowSys.CooTow.preHea.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 28, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("CooTow.CooTowSys.CooTow.preHea.Q_flow", "[W]", "CooTow.CooTowSys.CooTow.Q_flow", 1,\
 5, 95, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.preHea.port.T", "Port temperature [K|degC]",\
 "CooTow.CooTowSys.CooTow.TLvg", 1, 5, 94, 1028)
DeclareAlias2("CooTow.CooTowSys.CooTow.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CooTow.CooTowSys.CooTow.vol.heatPort.Q_flow", -1, 5, 63, 1156)
DeclareAlias2("CooTow.CooTowSys.CooTow.QWat_flow.y", "Value of Real output [W]",\
 "CooTow.CooTowSys.CooTow.Q_flow", 1, 5, 95, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.T_Vol.T", "Absolute temperature as output signal [K]",\
 "CooTow.CooTowSys.CooTow.TLvg", 1, 5, 94, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.T_Vol.port.T", "Port temperature [K|degC]",\
 "CooTow.CooTowSys.CooTow.TLvg", 1, 5, 94, 1028)
DeclareVariable("CooTow.CooTowSys.CooTow.T_Vol.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,2825)
DeclareParameter("CooTow.CooTowSys.CooTow.TApp", "Approach temperature difference [K,K]",\
 29, 2, 0.0,1E+100,1.0,0,560)
DeclareAlias2("CooTow.CooTowSys.CooTow.TAir", "Entering air dry or wet bulb temperature [K]",\
 "CooTow.TWea.k", 1, 7, 57, 0)
DeclareVariable("CooTow.CooTowSys.Pum.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("CooTow.CooTowSys.Pum.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 30, true, 0.0,0.0,0.0,0,562)
DeclareVariable("CooTow.CooTowSys.Pum.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("CooTow.CooTowSys.Pum.motorEfficiency.r_V[1]", "Volumetric flow rate divided by nominal flow rate at user-selected operating points [|1]",\
 31, 1, 0.0,1.0,0.0,0,560)
DeclareParameter("CooTow.CooTowSys.Pum.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 32, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("CooTow.CooTowSys.Pum.hydraulicEfficiency.r_V[1]", \
"Volumetric flow rate divided by nominal flow rate at user-selected operating points [|1]",\
 33, 1, 0.0,1.0,0.0,0,560)
DeclareParameter("CooTow.CooTowSys.Pum.hydraulicEfficiency.eta[1]", \
"Fan or pump efficiency at these flow rates [|1]", 34, 0.7, 0.0,1.0,0.0,0,560)
DeclareVariable("CooTow.CooTowSys.Pum.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.P", "Electrical power consumed [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.Q_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.eta", "Global efficiency [1]", 0.0, 0.0,\
1.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.etaHyd", "Hydraulic efficiency [1]", 0.0, \
0.0,1.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.etaMot", "Motor efficiency [1]", 0.0, 0.0,\
1.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.dpMachine", "Pressure increase [Pa|Pa]", -100,\
 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.VMachine_flow", "Volume flow rate [m3/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.V_flow_max", "Maximum volume flow rate, used for smoothing [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.motDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.hydDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.QThe_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("CooTow.CooTowSys.Pum.p_start", "Start value of pressure [Pa|bar]",\
 35, 300000.0, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("CooTow.CooTowSys.Pum.T_start", "Start value of temperature [K|degC]",\
 36, 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("CooTow.CooTowSys.Pum.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 37, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("CooTow.CooTowSys.Pum.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.Pum.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_b.m_flow", -1, 5, 37, 132)
DeclareAlias2("CooTow.CooTowSys.Pum.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", 1, 5, 209, 132)
DeclareVariable("CooTow.CooTowSys.Pum.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,300000.0,0,521)
DeclareAlias2("CooTow.CooTowSys.Pum.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareParameter("CooTow.CooTowSys.Pum.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 38, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.Pum.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 39, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.Pum.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.Pum.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.Pum.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_b.m_flow", -1, 5, 37, 0)
DeclareAlias2("CooTow.CooTowSys.Pum.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 "CooTow.CooTowSys.Pum.dpMachine", -1, 5, 107, 0)
DeclareVariable("CooTow.CooTowSys.Pum.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.vol.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.Pum.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.Pum.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.CooTowSys.CooTow.port_b.m_flow", -1, 5, 37, 132)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", 1, 5, 209, 132)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.heatPort.T", "Port temperature [K|degC]",\
 "CooTow.CooTowSys.Pum.heatPort.T", 1, 5, 150, 4)
DeclareVariable("CooTow.CooTowSys.Pum.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.T", "Temperature of the fluid [K|degC]",\
 "CooTow.CooTowSys.Pum.heatPort.T", 1, 5, 150, 0)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.p", "Pressure of the fluid [Pa|bar]", \
"CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 0)
DeclareVariable("CooTow.CooTowSys.Pum.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.state_start.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.useSteadyStateTwoPort", \
"Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.vol.QSen_flow.y", "Value of Real output [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("CooTow.CooTowSys.Pum.vol.masExc.k", "Constant output value [kg/s]",\
 40, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.masExc.y", "Connector of Real output signal [kg/s]",\
 "CooTow.CooTowSys.Pum.vol.masExc.k", 1, 7, 40, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.vol.tau", "Time constant at nominal flow [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.Pum.vol.V_nominal", "Volume of delay element [m3]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.dynamicBalance", "Set to true to use a dynamic balance, which often leads to smaller systems of equations [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.Pum.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("CooTow.CooTowSys.Pum.tau", "Time constant of fluid volume for nominal flow, used if dynamicBalance=true [s]",\
 41, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("CooTow.CooTowSys.Pum.heatPort.T", "Port temperature [K|degC]", \
288.15, 0.0,1E+100,300.0,0,520)
DeclareVariable("CooTow.CooTowSys.Pum.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("CooTow.CooTowSys.Pum.rho_in", "Density of inflowing fluid [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1156)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "bou1.ports[1].h_outflow", 1, 5, 226, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", 1, 5, 209, 1156)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,2569)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1028)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,2563)
DeclareParameter("CooTow.CooTowSys.Pum.preSou.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 42, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.state_a.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.state_b.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.control_m_flow", "= false to control dp instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.sta_start.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.control_m_flow", "= false to control head instead of m_flow [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CooTow.CooTowSys.Pum.r_V", "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal) [1]",\
 1, 0.0,0.0,0.0,0,512)
DeclareVariable("CooTow.CooTowSys.Pum.p_a_default", "Nominal inlet pressure for predefined fan or pump characteristics [Pa|Pa]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareParameter("CooTow.CooTowSys.Pum.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 43, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("CooTow.CooTowSys.Pum.sta_default.T", "Temperature of medium [K|degC]",\
 44, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareAlias2("CooTow.CooTowSys.Pum.m_flow_in", "Prescribed mass flow rate [kg/s]",\
 "const.k", 1, 7, 60, 0)
DeclareVariable("CooTow.CooTowSys.Pum.filteredSpeed", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("CooTow.CooTowSys.Pum.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 45, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("CooTow.CooTowSys.Pum.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("CooTow.CooTowSys.Pum.m_flow_start", "Initial value of mass flow rate [kg/s]",\
 46, 0, 0.0,1E+100,0.0,0,560)
DeclareAlias2("CooTow.CooTowSys.Pum.m_flow_actual", "Actual mass flow rate [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 0)
DeclareAlias2("CooTow.CooTowSys.Pum.filter.u", "Connector of Real input signal [kg/s]",\
 "const.k", 1, 7, 60, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.filter.y", "Connector of Real output signal [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.order", "Order of filter [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.f_cut", "Cut-off frequency [Hz]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("CooTow.CooTowSys.Pum.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 47, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("CooTow.CooTowSys.Pum.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 48, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("CooTow.CooTowSys.Pum.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 49, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("CooTow.CooTowSys.Pum.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 50, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.Pum.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.nx", "[:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,2565)
DeclareParameter("CooTow.CooTowSys.Pum.filter.x_start[1]", "Initial or guess values of states",\
 51, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("CooTow.CooTowSys.Pum.filter.x_start[2]", "Initial or guess values of states",\
 52, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("CooTow.CooTowSys.Pum.filter.y_start", "Initial value of output [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.filter.u_nominal", "Nominal value of input (used for scaling the states) [kg/s]",\
 10, 0.0,0.0,0.0,0,2561)
DeclareState("CooTow.CooTowSys.Pum.filter.x[1]", "Filter states", 0, 0.0, \
0.0,0.0,0.0,0,2592)
DeclareDerivative("CooTow.CooTowSys.Pum.filter.der(x[1])", "der(Filter states)",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("CooTow.CooTowSys.Pum.filter.x[2]", "Filter states", 1, 0.0, \
0.0,0.0,0.0,0,2592)
DeclareDerivative("CooTow.CooTowSys.Pum.filter.der(x[2])", "der(Filter states)",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.filter.ncr", "[:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.nc0", "[:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.na", "[:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.nr", "[:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.filter.uu[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.Pum.filter.uu[2]", "", "CooTow.CooTowSys.Pum.filter.x[1]", 1,\
 1, 0, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.filter.uu[3]", "", "CooTow.CooTowSys.Pum.filter.x[2]", 1,\
 1, 1, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.m_flow_filtered", "Filtered mass flow rate [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1024)
DeclareVariable("CooTow.CooTowSys.TemSen.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CooTow.CooTowSys.TemSen.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 132)
DeclareVariable("CooTow.CooTowSys.TemSen.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("CooTow.CooTowSys.TemSen.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "bou1.ports[1].h_outflow", 1, 5, 226, 4)
DeclareAlias2("CooTow.CooTowSys.TemSen.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", 1, 5, 209, 132)
DeclareVariable("CooTow.CooTowSys.TemSen.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("CooTow.CooTowSys.TemSen.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareParameter("CooTow.CooTowSys.TemSen.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 53, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.TemSen.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 54, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CooTow.CooTowSys.TemSen.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 55, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.TemSen.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.TemSen.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.TemSen.tau", "Time constant at nominal flow rate [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("CooTow.CooTowSys.TemSen.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("CooTow.CooTowSys.TemSen.k", "Gain to take flow rate into account for sensor time constant [1]",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.TemSen.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.TemSen.mNor_flow", "Normalized mass flow rate [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("CooTow.CooTowSys.TemSen.T", "Temperature of the passing fluid [K|degC]",\
 2, 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("CooTow.CooTowSys.TemSen.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("CooTow.CooTowSys.TemSen.T_start", "Initial or guess value of output (= state) [K|degC]",\
 56, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("CooTow.CooTowSys.TemSen.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("CooTow.CooTowSys.TemSen.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 300, 1.0,10000.0,300.0,0,2560)
DeclareVariable("CooTow.CooTowSys.TemSen.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", 1, 5, 209, 132)
DeclareVariable("CooTow.CooTowSys.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("CooTow.CooTowSys.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 4)
DeclareAlias2("CooTow.CooTowSys.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boundary.m_flow", 1, 7, 61, 132)
DeclareAlias2("CooTow.CooTowSys.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareAlias2("CooTow.CooTowSys.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_a1.h_outflow", 1, 5, 208, 4)
DeclareAlias2("CooTow.CooTowSys.TWea", "Entering air dry or wet bulb temperature [K]",\
 "CooTow.TWea.k", 1, 7, 57, 0)
DeclareAlias2("CooTow.CooTowSys.m_flo_in", "Prescribed mass flow rate [kg/s]", \
"const.k", 1, 7, 60, 0)
DeclareParameter("CooTow.TWea.k", "Constant output value [K]", 57, 296.65, 0.0,\
1E+100,300.0,0,560)
DeclareAlias2("CooTow.TWea.y", "Connector of Real output signal [K]", \
"CooTow.TWea.k", 1, 7, 57, 0)
DeclareAlias2("CooTow.m_flo_in", "Prescribed mass flow rate [kg/s]", "const.k", 1,\
 7, 60, 0)
DeclareAlias2("CooTow.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boundary.m_flow", 1, 7, 61, 132)
DeclareAlias2("CooTow.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareVariable("CooTow.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("CooTow.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,10.0,0,776)
DeclareVariable("CooTow.port_b1.der(m_flow)", "der(Mass flow rate from the connection point into the component) [kg/s2]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("CooTow.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("CooTow.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("bou1.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("bou1.medium.p", "Absolute pressure of medium [Pa|bar]", 100.0, \
0.0,1E+100,100000.0,0,513)
DeclareAlias2("bou1.medium.h", "Specific enthalpy of medium [J/kg]", \
"bou1.ports[1].h_outflow", 1, 5, 226, 0)
DeclareVariable("bou1.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareAlias2("bou1.medium.T", "Temperature of medium [K|degC]", "bou1.T", 1, 7,\
 58, 0)
DeclareVariable("bou1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("bou1.medium.u", "Specific internal energy of medium [J/kg]", \
0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("bou1.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("bou1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("bou1.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
100.0, 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("bou1.medium.state.T", "Temperature of medium [K|degC]", "bou1.T", 1,\
 7, 58, 0)
DeclareVariable("bou1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("bou1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("bou1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("bou1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareAlias2("bou1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 132)
DeclareVariable("bou1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("bou1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("bou1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("bou1.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.p", "Fixed value of pressure [Pa|bar]", 100, 0.0,\
100000000.0,100000.0,0,513)
DeclareParameter("bou1.T", "Fixed value of temperature [K|degC]", 58, 293.15, \
1.0,10000.0,300.0,0,560)
DeclareParameter("bou1.X[1]", "Fixed value of composition [kg/kg]", 59, 1.0, 0.0,\
1.0,0.1,0,560)
DeclareVariable("bou1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 100.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("bou1.T_in_internal", "Needed to connect to conditional connector [K]",\
 "bou1.T", 1, 7, 58, 1024)
DeclareVariable("bou1.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("const.k", "Constant output value [kg/s]", 60, 10, 0.0,0.0,10.0,\
0,560)
DeclareAlias2("const.y", "Connector of Real output signal [kg/s]", "const.k", 1,\
 7, 60, 0)
DeclareVariable("boundary.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("boundary.medium.p", "Absolute pressure of medium [Pa|bar]", \
"CooTow.CooTowSys.bou.p", 1, 7, 7, 0)
DeclareAlias2("boundary.medium.h", "Specific enthalpy of medium [J/kg]", \
"boundary.ports[1].h_outflow", 1, 5, 245, 0)
DeclareVariable("boundary.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586,\
 0.0,100000.0,1.0,0,513)
DeclareAlias2("boundary.medium.T", "Temperature of medium [K|degC]", \
"boundary.T", 1, 7, 62, 0)
DeclareVariable("boundary.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boundary.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("boundary.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("boundary.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("boundary.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 0)
DeclareAlias2("boundary.medium.state.T", "Temperature of medium [K|degC]", \
"boundary.T", 1, 7, 62, 0)
DeclareVariable("boundary.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("boundary.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boundary.m_flow", -1, 7, 61, 132)
DeclareAlias2("boundary.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.bou.p", 1, 7, 7, 4)
DeclareVariable("boundary.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("boundary.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("boundary.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("boundary.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 61, 0, -100000.0,100000.0,0.0,0,560)
DeclareParameter("boundary.T", "Fixed value of temperature [K|degC]", 62, 293.15,\
 1.0,10000.0,300.0,0,560)
DeclareParameter("boundary.X[1]", "Fixed value of composition [kg/kg]", 63, 1.0,\
 0.0,1.0,0.1,0,560)
DeclareAlias2("boundary.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "boundary.m_flow", 1, 7, 61, 1024)
DeclareAlias2("boundary.T_in_internal", "Needed to connect to conditional connector [K]",\
 "boundary.T", 1, 7, 62, 1024)
DeclareVariable("boundary.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.energyDynamics", \
"Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.massDynamics", \
"Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.substanceDynamics", \
"Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, \
1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.traceDynamics", \
"Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.X_start[1]", \
"Start value of mass fractions m_i/m [kg/kg]", 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[1].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"CooTow.CooTowSys.CooTow.port_a.m_flow", 1, 5, 35, 1156)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1028)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[1].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 1028)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[2].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"CooTow.CooTowSys.CooTow.port_b.m_flow", 1, 5, 37, 1156)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1028)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.ports[2].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 1028)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,300000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.der(p)", \
"der(Absolute pressure of medium) [Pa/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 1024)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("CooTow.CooTowSys.CooTow.vol.dynBal.medium.T", "Temperature of medium [K|degC]",\
 3, 293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("CooTow.CooTowSys.CooTow.vol.dynBal.medium.der(T)", \
"der(Temperature of medium) [K/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.X[1]", \
"Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]", 1.0, 0.0,1.0,\
0.1,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.der(u)", \
"der(Specific internal energy of medium) [m2/s3]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,2561)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.medium.state.p", \
"Absolute pressure of medium [Pa|bar]", "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1,\
 5, 260, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.medium.state.T", \
"Temperature of medium [K|degC]", "CooTow.CooTowSys.CooTow.vol.dynBal.medium.T", 1,\
 1, 3, 1024)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.preferredMediumStates",\
 "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.standardOrderComponents",\
 "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.T_degC", \
"Temperature of medium in [degC] [degC;]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.medium.p_bar", \
"Absolute pressure of medium in [bar] [bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.U", "Internal energy of fluid [J]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.m", "Mass of fluid [kg]", \
0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 "CooTow.CooTowSys.CooTow.vol.masExc.k", -1, 7, 17, 1024)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.fluidVolume", "Volume [m3]", \
"CooTow.CooTowSys.CooTow.vol.V", 1, 5, 61, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 "CooTow.CooTowSys.CooTow.vol.heatPort.Q_flow", 1, 5, 63, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 "CooTow.CooTowSys.CooTow.vol.masExc.k", 1, 7, 17, 1024)
DeclareAlias2("CooTow.CooTowSys.CooTow.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "CooTow.CooTowSys.CooTow.port_a.h_outflow", 1, 5, 36, 1024)
DeclareParameter("CooTow.CooTowSys.CooTow.vol.dynBal.initialize_p", \
"= true to set up initial equations for pressure [:#(type=Boolean)]", 64, false,\
 0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.ports_H_flow[1]", "[W]", 0.0,\
 -100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.ports_H_flow[2]", "[W]", 0.0,\
 -100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.rho_nominal", \
"Density, used to compute fluid mass [kg/m3|g/cm3]", 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.CooTow.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.energyDynamics", \
"Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.substanceDynamics", \
"Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, \
1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.traceDynamics", \
"Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[1].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"CooTow.CooTowSys.CooTow.port_b.m_flow", -1, 5, 37, 1156)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[1].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[2].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"CooTow.port_b1.m_flow", 1, 5, 209, 1156)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.ports[2].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1028)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.medium.der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.der(p)", 1, 5, 261, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("CooTow.CooTowSys.Pum.vol.dynBal.medium.T", "Temperature of medium [K|degC]",\
 4, 293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("CooTow.CooTowSys.Pum.vol.dynBal.medium.der(T)", \
"der(Temperature of medium) [K/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.der(u)", \
"der(Specific internal energy of medium) [m2/s3]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,2561)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "CooTow.CooTowSys.CooTow.vol.dynBal.medium.p", 1, 5, 260, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "CooTow.CooTowSys.Pum.vol.dynBal.medium.T", 1, 1, 4, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.standardOrderComponents",\
 "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.T_degC", \
"Temperature of medium in [degC] [degC;]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.U", "Internal energy of fluid [J]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.m", "Mass of fluid [kg]", 0.0, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 "CooTow.CooTowSys.Pum.vol.masExc.k", -1, 7, 40, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 "CooTow.CooTowSys.Pum.vol.dynBal.der(U)", 1, 5, 300, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.fluidVolume", "Volume [m3]", \
"CooTow.CooTowSys.Pum.vol.V", 1, 5, 135, 1024)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 "CooTow.CooTowSys.Pum.vol.masExc.k", 1, 7, 40, 1024)
DeclareAlias2("CooTow.CooTowSys.Pum.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "CooTow.port_b1.h_outflow", 1, 5, 212, 1024)
DeclareParameter("CooTow.CooTowSys.Pum.vol.dynBal.initialize_p", \
"= true to set up initial equations for pressure [:#(type=Boolean)]", 65, false,\
 0.0,0.0,0.0,0,2610)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CooTow.CooTowSys.Pum.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CooTow.CooTowSys.Pum.preSou.m_flow_in", "Prescribed mass flow rate [kg/s]",\
 "CooTow.port_b1.m_flow", -1, 5, 209, 1024)
EndNonAlias(0)
#define NX_    5
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    308
#define NP_    66
#define NPS_   0
#define MAXAuxStr_   1
#define MAXAuxStrLen_   500
#define NHash1_ 1361677841
#define NHash2_ -74210874
#define NHash3_ 0
#define NI_    0
#define NRelF_ 5
#define NRel_  5
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    133
#define SizePre_ 0
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 19
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 25
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
StartEqBlock
DoRemember_(W_[101], 0.0, 2);
DoRemember_(W_[265], 0.0, 1);
DoRemember_(W_[292], 0.0, 0);
EndEqBlock
EndDataBlock
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
