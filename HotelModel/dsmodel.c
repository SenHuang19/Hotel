/* DSblock model generated by Dymola from Modelica model HotelModel.HeatPumpSection.BoilerPackage.TestwithConstantforBoiler
 Dymola Version 2015 (32-bit), 2014-04-11 translated this at Tue Aug 26 16:52:47 2014

   */

#include <matrixop.h>
static const char* DymArrays0[1]={"SimpleLiquidWater"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der5, double  kx_0der5, double  mx_0flowx_0turbulentx_0der5);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real kSquInv(unit = "1/(kg.m)") "Flow coefficient";
public 
algorithm 
kSquInv := 1/k^2;
dp := Modelica.Fluid.Utilities.regSquare2(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1);
annotation(derivative=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf, LateInline=true, smoothOrder=2);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    dp0_0=0;
    kSquInv0_0=0;
    /* Start of real code */
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dp0_0 = Modelica_Fluid_Utilities_regSquare2(mx_0flow, mx_0flowx_0turbulent,
         kSquInv0_0, kSquInv0_0, false, 1);
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf
discrete input Real m_flow;
discrete input Real k;
discrete input Real m_flow_turbulent;
protected 
discrete Real dp;
discrete Real kSquInv;
public 
discrete input Real m_flow_der5;
discrete input Real k_der5;
discrete input Real m_flow_turbulent_der5;
discrete output Real dp_der5;
protected 
discrete Real kSquInv_der5;
public 
algorithm 
kSquInv_der5 :=  -2.0*(k*k_der5)/(k^2)^2;
kSquInv := 1/k^2;
dp_der5 := Modelica.Fluid.Utilities.regSquare2:der(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1, m_flow_der5, m_flow_turbulent_der5, kSquInv_der5, kSquInv_der5, 0);
annotation(smoothOrder=1);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf;

  */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der5, double  kx_0der5, double  mx_0flowx_0turbulentx_0der5) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    double   dpx_0der5;
    double   kSquInvx_0der5;
    dp0_0=0;
    kSquInv0_0=0;
    dpx_0der5=0;
    kSquInvx_0der5=0;
    /* Start of real code */
      kSquInvx_0der5 =  -divmacro(2.0*k0_0*kx_0der5,"2.0*(k*k_der5)",sqr(sqr(
        k0_0)),"(k^2)^2");
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dpx_0der5 = Modelica_Fluid_Utilities_regSquare2__der(mx_0flow, 
        mx_0flowx_0turbulent, kSquInv0_0, kSquInv0_0, false, 1, mx_0flowx_0der5,
         mx_0flowx_0turbulentx_0der5, kSquInvx_0der5, kSquInvx_0der5, 0);
    /* Output section */
    PopContext()
    return dpx_0der5;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , 
        double );
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
        const char* , double  const *, size_t, size_t, int  const *, size_t, int );
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D.destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D.destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)(i0_0_0)), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)(i0_0_0))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
discrete input Real k2(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then k1*x^2 else (if x <=  -x_small then  -k2*x^2 else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN k10_0*sqr(x0_0) ELSE IF x0_0 <=  -
        xx_0small THEN  -k20_0*sqr(x0_0) ELSE IF k10_0 >= k20_0 THEN 
        Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(x0_0, xx_0small,
         k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
discrete input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
algorithm 
x2 :=  -x1;
if (x <= x2) then 
y :=  -k2*x^2;
else
y1 := k1*x1^2;
y2 :=  -k2*x2^2;
y1d := k1*2*x1;
y2d :=  -k2*2*x2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := 2.23606797749979*k1*x1;
w2 := 2.23606797749979*k2*abs(x2);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d := ww;
end if;
y := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x2, y2, y2d, y0d));
end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    /* Start of real code */
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        y0_0 =  -k20_0*sqr(x0_0);
      }
      else{
        y10_0 = k10_0*sqr(x10_0);
        y20_0 =  -k20_0*sqr(x20_0);
        y1d0_0 = k10_0*2*x10_0;
        y2d0_0 =  -k20_0*2*x20_0;
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0d0_0 = ww0_0;
        }
        y0_0 = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2:der
discrete input Real x;
discrete input Real x_small(start = 0.01);
discrete input Real k1(start = 1);
discrete input Real k2(start = 1);
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x_small_der(start = 0.0);
discrete input Real k1_der(start = 0);
discrete input Real k2_der(start = 0);
discrete input Real yd0_der(start = 0);
discrete output Real y_der;

algorithm 
y_der := smooth(1, (if x >= x_small then k1_der*x^2+2.0*(k1*(x*x_der)) else (if x <=  -x_small then  -(k2_der*x^2+2.0*(k2*(x*x_der))) else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der(x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, yd0_der) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der( -x, x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN k1x_0der*sqr(x0_0)+2.0*k10_0*x0_0*
        xx_0der ELSE IF x0_0 <=  -xx_0small THEN  -(k2x_0der*sqr(x0_0)+2.0*k20_0
        *x0_0*xx_0der) ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
discrete input Real x "Value for which polynomial shall be evaluated";
discrete input Real x1 "Abscissa value";
discrete input Real y1 "y1=f(x1)";
discrete input Real y1d "First derivative at y1";
discrete input Real y0d "First derivative at f(x=0)";
discrete output Real y;
protected 
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
algorithm 
a1 := x1*y0d;
a2 := 3*y1-x1*y1d-2*a1;
a3 := y1-a2-a1;
xx := x/x1;
y := xx*(a1+xx*(a2+xx*a3));
annotation(derivative=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der, smoothOrder=3);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    /* Start of real code */
      a10_0 = x10_0*y0d0_0;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a30_0 = y10_0-a20_0-a10_0;
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      y0_0 = xx0_0*(a10_0+xx0_0*(a20_0+xx0_0*a30_0));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der
discrete input Real x;
discrete input Real x1;
discrete input Real k1;
discrete input Real k2;
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real k1_der;
discrete input Real k2_der;
discrete input Real yd0_der(start = 0);
discrete output Real y_der;
protected 
discrete Real x2_der;
discrete Real y1_der;
discrete Real y2_der;
discrete Real y1d_der;
discrete Real y2d_der;
discrete Real w_der;
discrete Real w1_der;
discrete Real w2_der;
discrete Real y0d_der;
discrete Real ww_der;
public 
algorithm 
x2_der :=  -x1_der;
x2 :=  -x1;
if (x <= x2) then 
y_der :=  -(k2_der*x^2+2.0*(k2*(x*x_der)));
else
y1_der := k1_der*x1^2+2.0*(k1*(x1*x1_der));
y1 := k1*x1^2;
y2_der :=  -(k2_der*x2^2+2.0*(k2*(x2*x2_der)));
y2 :=  -k2*x2^2;
y1d_der := 2.0*(k1_der*x1+k1*x1_der);
y1d := 2.0*(k1*x1);
y2d_der := (-2.0)*(k2_der*x2+k2*x2_der);
y2d := (-2.0)*(k2*x2);
if (use_yd0) then 
y0d_der := yd0_der;
y0d := yd0;
else
w_der := x2_der/x1-x2*x1_der/x1^2;
w := x2/x1;
y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-((3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2.0*(x1*(1-w)))-2.0*(((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der))/(2.0*(x1*(1-w)))^2;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2.0*(x1*(1-w)));
end if;
w1_der := 2.23606797749979*(k1_der*x1+k1*x1_der);
w1 := 2.23606797749979*(k1*x1);
w2_der := 2.23606797749979*(k2_der*abs(x2)+k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))));
w2 := 2.23606797749979*(k2*abs(x2));
ww_der := 0.9*(if w1 < w2 then w1_der else w2_der);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d_der := ww_der;
y0d := ww;
end if;
y_der := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x1, y1, y1d, y0d, x_der, x1_der, y1_der, y1d_der, y0d_der) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x2, y2, y2d, y0d, x_der, x2_der, y2_der, y2d_der, y0d_der));
end if;
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    double   yx_0der;
    double   x2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   w1x_0der;
    double   w2x_0der;
    double   y0dx_0der;
    double   wwx_0der;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    yx_0der=0;
    x2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    y0dx_0der=0;
    wwx_0der=0;
    /* Start of real code */
      x2x_0der =  -x1x_0der;
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        yx_0der =  -(k2x_0der*sqr(x0_0)+2.0*k20_0*x0_0*xx_0der);
      }
      else{
        y1x_0der = k1x_0der*sqr(x10_0)+2.0*k10_0*x10_0*x1x_0der;
        y10_0 = k10_0*sqr(x10_0);
        y2x_0der =  -(k2x_0der*sqr(x20_0)+2.0*k20_0*x20_0*x2x_0der);
        y20_0 =  -k20_0*sqr(x20_0);
        y1dx_0der = 2.0*(k1x_0der*x10_0+k10_0*x1x_0der);
        y1d0_0 = 2.0*k10_0*x10_0;
        y2dx_0der = (-2.0)*(k2x_0der*x20_0+k20_0*x2x_0der);
        y2d0_0 = (-2.0)*k20_0*x20_0;
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1.0,"1.0",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1.0,"1.0",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2.0*x10_0*helpvar[8];
          helpvar[10] = divmacro(1.0,"1.0",helpvar[9],"2.0*(x1*(1-w))");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1.0,"1.0",helpvar[15],"(2.0*(x1*(1-w)))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2.0*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2.0*
            x10_0*(1-w0_0),"2.0*(x1*(1-w))");
        }
        w1x_0der = 2.23606797749979*(k1x_0der*x10_0+k10_0*x1x_0der);
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w2x_0der = 2.23606797749979*(k2x_0der*fabs(x20_0)+k20_0*x2x_0der*(IF 
          x20_0 > 0 THEN 1 ELSE -1));
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        wwx_0der = 0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0dx_0der = wwx_0der;
          y0d0_0 = ww0_0;
        }
        yx_0der = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0, xx_0der, x1x_0der, y1x_0der, 
          y1dx_0der, y0dx_0der) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0, xx_0der, x2x_0der, y2x_0der, 
          y2dx_0der, y0dx_0der);
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der
discrete input Real x;
discrete input Real x1;
discrete input Real y1;
discrete input Real y1d;
discrete input Real y0d;
protected 
discrete Real y;
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real y1_der;
discrete input Real y1d_der;
discrete input Real y0d_der;
discrete output Real y_der;
protected 
discrete Real a1_der;
discrete Real a2_der;
discrete Real a3_der;
discrete Real xx_der;
public 
algorithm 
a1_der := x1_der*y0d+x1*y0d_der;
a1 := x1*y0d;
a2_der := 3*y1_der-(x1_der*y1d+x1*y1d_der)-2*a1_der;
a2 := 3*y1-x1*y1d-2*a1;
a3_der := y1_der-a2_der-a1_der;
a3 := y1-a2-a1;
xx_der := x_der/x1-x*x1_der/x1^2;
xx := x/x1;
y_der := xx_der*(a1+xx*(a2+xx*a3))+xx*(a1_der+xx_der*(a2+xx*a3)+xx*(a2_der+xx_der*a3+xx*a3_der));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    double   yx_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   a3x_0der;
    double   xxx_0der;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    yx_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    a3x_0der=0;
    xxx_0der=0;
    /* Start of real code */
      a1x_0der = x1x_0der*y0d0_0+x10_0*y0dx_0der;
      a10_0 = x10_0*y0d0_0;
      a2x_0der = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der)-2*a1x_0der;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a3x_0der = y1x_0der-a2x_0der-a1x_0der;
      a30_0 = y10_0-a20_0-a10_0;
      xxx_0der = divmacro(xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,
        "x*x1_der",sqr(x10_0),"x1^2");
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      yx_0der = xxx_0der*(a10_0+xx0_0*(a20_0+xx0_0*a30_0))+xx0_0*(a1x_0der+
        xxx_0der*(a20_0+xx0_0*a30_0)+xx0_0*(a2x_0der+xxx_0der*a30_0+xx0_0*
        a3x_0der));
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(4)
BreakSectionFunctionDef(5)
BreakSectionFunctionDef(6)
BreakSectionFunctionDef(7)
BreakSectionFunctionDef(8)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
DYMOLA_STATIC const char*modelName="HotelModel.HeatPumpSection.BoilerPackage.TestwithConstantforBoiler";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/german/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[14]={5 , 4 , 1 , 3 , 5 , 7 , 1 , 2 , 1 , 4 , 1
   , 6 , 1 , 8};
DYMOLA_STATIC long QJacobianGC_[41]={
1 , 1 , 3 , 3 , 5 , 7 , 7 , 0 , 0 , 2 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 4 , 4
   , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 6 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 , 8 , 8
   , 0};
DYMOLA_STATIC double QJacobianCD_[9]={0  , 44 , 50 , 66 , 63 , 88 , 72 , 110 , 77};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = true;
W_[10] = 10;
W_[11] = 100;
W_[12] = 10;
W_[13] = 100;
W_[14] = 10;
W_[15] = 100;
W_[16] = true;
W_[23] = 10;
W_[25] = true;
W_[32] = 100;
W_[37] = 1;
W_[38] = 1;
W_[39] = 1;
W_[40] = 1;
W_[41] = 1;
W_[42] = 1;
W_[47] = 2;
W_[51] = false;
W_[58] = 1.0;
W_[63] = false;
W_[64] = true;
W_[66] = 10;
W_[68] = false;
W_[71] = 100;
W_[76] = 10;
W_[77] = 100;
W_[106] = true;
W_[108] = 10;
W_[110] = false;
W_[118] = 10;
W_[120] = 1;
W_[126] = true;
W_[129] = 1;
W_[130] = 1;
W_[131] = 2;
W_[134] = 2;
W_[136] = 2;
W_[137] = 0;
W_[138] = 0;
W_[139] = 2;
W_[149] = true;
W_[154] = 10;
W_[156] = false;
W_[164] = 10;
W_[166] = 1;
W_[172] = true;
W_[176] = 1;
W_[177] = 1;
W_[178] = 2;
W_[181] = 2;
W_[183] = 2;
W_[184] = 0;
W_[185] = 0;
W_[186] = 2;
W_[202] = 2;
W_[212] = 4;
W_[216] = 1;
W_[229] = true;
W_[230] = true;
W_[232] = true;
W_[238] = true;
W_[257] = 1;
W_[269] = 3;
W_[270] = false;
W_[271] = false;
W_[272] = false;
W_[273] = false;
W_[277] = 1;
W_[291] = 3;
W_[292] = false;
W_[293] = false;
W_[294] = false;
W_[295] = false;
W_[299] = 1;
W_[300] = 1;
W_[301] = 1;
W_[306] = 2;
DYNSetAuxString("SimpleLiquidWater", 2);
W_[33] = false;
W_[127] = 4;
W_[173] = 4;
W_[1] = 1;
W_[2] = 1;
W_[3] = 1;
W_[4] = 1;
W_[5] = 4;
W_[8] = false;
W_[24] = 0.001;
W_[30] = true;
W_[31] = false;
W_[82] = 995.586;
W_[36] = true;
W_[46] = 10;
W_[48] = 0.001;
W_[49] = true;
W_[56] = 995.586;
W_[57] = 995.586;
W_[59] = 300000.0;
W_[60] = 293.15;
W_[67] = 0.001;
W_[70] = false;
W_[72] = true;
W_[73] = false;
W_[81] = true;
W_[78] = false;
W_[75] = 0.001;
W_[80] = 1.0;
W_[109] = 0.001;
W_[112] = false;
W_[124] = 100;
W_[114] = true;
W_[115] = false;
W_[117] = 0.001;
W_[133] = 4;
W_[155] = 0.001;
W_[158] = false;
W_[170] = 100;
W_[160] = true;
W_[161] = false;
W_[163] = 0.001;
W_[180] = 4;
DYNSetAuxString("NoName", 0);
DYNSetAuxString("NoName", 1);
W_[205] = 2;
W_[206] = 3;
W_[213] = 5;
W_[214] = true;
W_[215] = false;
W_[227] = false;
W_[228] = true;
W_[235] = 0;
W_[236] = 0;
W_[241] = 10;
W_[242] = 0.001;
W_[244] = 3;
W_[263] = false;
W_[264] = true;
W_[274] = 10;
W_[285] = false;
W_[286] = true;
W_[296] = 100;
W_[302] = 1;
W_[317] = true;
W_[318] = true;
W_[328] = 995.586;
W_[334] = 3;
W_[339] = 1;
W_[34] = 0.1;
W_[86] = 1;
W_[201] = 2;
W_[204] = false;
W_[207] = 1;
W_[243] = 1;
W_[105] = 0;
W_[324] = 0.0;
W_[254] = 10;
W_[309] = 100;
W_[261] = 0;
W_[282] = 0;
W_[288] = 0.001;
W_[314] = 0;
W_[320] = 0.001;
W_[324] = 0.0;
W_[324] = 0.0;
W_[239] = 100.0;
W_[240] = 100.0;
W_[94] = 0.0;
W_[96] = 0.0;
W_[97] = 0.0;
W_[100] = 0.0;
W_[22] = 100.0;
W_[65] = 100.0;
W_[28] = 100.0;
W_[315] = 0.018015268;
W_[311] = 1.0;
W_[310] = 995.586;
W_[316] = 100.0;
W_[307] = 100.0;
W_[308] = 100.0;
W_[55] = 100.0;
W_[52] = 100.0;
W_[53] = 100.0;
W_[197] = 10.0;
W_[196] = 100.0;
W_[152] = 100.0;
W_[252] = 100.0;
W_[237] = 10.0;
W_[233] = 10.0;
W_[234] = -10.0;
W_[283] = 0.018015268;
W_[280] = 1.0;
W_[279] = 995.586;
W_[278] = 100.0;
W_[284] = 100.0;
W_[297] = 100.0;
W_[289] = 100.0;
W_[275] = 10.0;
W_[262] = 0.018015268;
W_[259] = 1.0;
W_[258] = 995.586;
W_[267] = -10.0;
BoundParameterSection
AssertModelica(DP_[45] > -1E-060,"boiler2WithControls.boi.valBoi.dpFixed_nominal > -1E-060",
   StringAdd(StringAdd("Require dpFixed_nominal >= 0. Received dpFixed_nominal = ",
  Real2String2(DP_[45], true, 0))," Pa."));
PopAllMarks();
AssertModelica(DP_[46] > 0,"boiler2WithControls.boi.valBoi.l > 0", 
  "Valve leakage parameter l must be bigger than zero.");
AssertModelica(DP_[63] > -1E-060,"boiler2WithControls.boi.valByp.dpFixed_nominal > -1E-060",
   StringAdd(StringAdd("Require dpFixed_nominal >= 0. Received dpFixed_nominal = ",
  Real2String2(DP_[63], true, 0))," Pa."));
PopAllMarks();
AssertModelica(DP_[64] > 0,"boiler2WithControls.boi.valByp.l > 0", 
  "Valve leakage parameter l must be bigger than zero.");
AssertModelica(DP_[44] > 0,"boiler2WithControls.boi.valBoi.filter.u_nominal > 0",
   "u_nominal > 0 required");
AssertModelica(DP_[39] > 0,"boiler2WithControls.boi.valBoi.filter.A_ripple > 0",
   "A_ripple > 0 required");
AssertModelica(DP_[62] > 0,"boiler2WithControls.boi.valByp.filter.u_nominal > 0",
   "u_nominal > 0 required");
AssertModelica(DP_[57] > 0,"boiler2WithControls.boi.valByp.filter.A_ripple > 0",
   "A_ripple > 0 required");
AssertModelica(DP_[94] >= DP_[95],"boiler2WithControls.bolCon.conPID.yMax >= boiler2WithControls.bolCon.conPID.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[94], true, 0)),") < yMin (="),Real2String2(DP_[95], true, 0)),
  ")"));
PopAllMarks();
AssertModelica(DP_[115] >= 272.15 AND DP_[115] <= 403.15,"boundary.T >= 272.15 and boundary.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DP_[115], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(DP_[117] >= 272.15 AND DP_[117] <= 403.15,"bou1.T >= 272.15 and bou1.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DP_[117], true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[88] = 1.5E-006*DP_[23];
W_[35] = 0.1*W_[88]*W_[82];
W_[43] = DP_[10];
W_[44] = DP_[11];
W_[45] = DP_[12];
W_[50] = divmacro(10*W_[35],"10*boiler2WithControls.boi.boi.tau",W_[82],
  "boiler2WithControls.boi.boi.rho_default");
W_[61] = W_[43];
W_[62] = W_[44];
W_[79] = W_[34];
W_[74] = IF W_[81] AND W_[78] THEN 0.7853981633974483*W_[75]*DP_[19]*DP_[20]
   ELSE IF W_[81] THEN 10*W_[79] ELSE 0;
W_[83] = DP_[10];
W_[84] = DP_[11];
W_[85] = 4184*(W_[84]-273.15);
W_[87] = 0.0016666666666666668*DP_[23];
W_[89] = 0.0015*DP_[23];
W_[98] = W_[87];
W_[101] = 500*W_[89];
W_[113] = W_[124]+DP_[45];
W_[116] = 10*DP_[34];
W_[119] = fabs(W_[113]);
W_[132] = divmacro(5,"5",6.283185307179586*DP_[36],"6.283185307179586*boiler2WithControls.boi.valBoi.riseTime");
W_[135] = DP_[37];
W_[146] = IF DP_[45] > 1E-060 THEN divmacro(10,"10",sqrtGuarded(DP_[45],
  "boiler2WithControls.boi.valBoi.dpFixed_nominal"),"sqrt(boiler2WithControls.boi.valBoi.dpFixed_nominal)")
   ELSE 0;
W_[159] = W_[170]+DP_[63];
W_[162] = 10*DP_[52];
W_[165] = fabs(W_[159]);
W_[179] = divmacro(5,"5",6.283185307179586*DP_[54],"6.283185307179586*boiler2WithControls.boi.valByp.riseTime");
W_[182] = DP_[55];
W_[193] = IF DP_[63] > 1E-060 THEN divmacro(10,"10",sqrtGuarded(DP_[63],
  "boiler2WithControls.boi.valByp.dpFixed_nominal"),"sqrt(boiler2WithControls.boi.valByp.dpFixed_nominal)")
   ELSE 0;
W_[231] = IF DP_[107] THEN -1 ELSE 1;
W_[218] = W_[231]*DP_[96];
W_[219] =  -W_[231];
W_[221] = DP_[91];
W_[225] = DP_[94];
W_[226] = DP_[95];
W_[246] = W_[243] > 1E-010 OR W_[243] < -1E-010;
W_[303] = W_[43];
W_[304] = W_[44];
W_[305] = W_[45];
W_[329] = 4184*(W_[304]-273.15);
W_[331] = W_[231]*DP_[97];
W_[332] =  -W_[231];
W_[333] = divmacro(1,"1",DP_[92],"boiler2WithControls.bolCon.conPID.Ti");
W_[335] = DP_[100];
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
W_[337] = DP_[93];
helpvar[0] = divmacro(1.0,"1.0",DP_[99],"boiler2WithControls.bolCon.conPID.Nd");
W_[338] = RealBmax(helpvar[0]*DP_[93], 1E-014);
W_[340] = DP_[101];
if (NewParameters) {
helpvar[1] = fabs(W_[337]);
}
W_[341] = fabs(W_[337]) < 1E-015;
W_[342] = W_[231];
W_[343] =  -W_[231];
W_[346] = divmacro(1,"1",DP_[91]*DP_[98],"boiler2WithControls.bolCon.conPID.k*boiler2WithControls.bolCon.conPID.Ni");
W_[330] = W_[331]*DP_[90]+W_[332]*DP_[119];
W_[217] = W_[218]*DP_[90]+W_[219]*DP_[119];
W_[220] = DP_[103]*W_[217];
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", boiler2WithControls.bolCon.combiTable1D.table, boiler2WithControls.bolCon.combiTable1D.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DP_[68], 2, 7, 3), IntegerTemporaryDense( &W_[205], 1, 2),
     1, 0, 1));
  W_[208] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
W_[200] = DP_[120];
W_[290] = 4184*(DP_[117]-273.15);
W_[323] = 995.586*W_[50];
W_[268] = 4184*(DP_[115]-273.15);
W_[250] = 273.15+0.0002390057361376673*W_[290];
W_[276] = DP_[116];
W_[298] = DP_[118];
Aux_[6] = W_[268];
Aux_[7] = W_[290];
 /* Linear system of equations to solve. */
W_[95] = 0.0;
SolveScalarLinearParametric( -W_[98]," -boiler2WithControls.boi.boi.UAOve.G", 
  0.0,"0.0", W_[95],"boiler2WithControls.boi.boi.UAOve.dT");
 /* End of Equation Block */ 

W_[211] = DP_[90]-DP_[119];
W_[260] = 4184*(DP_[115]-273.15);
W_[265] = DP_[115]-273.15;
W_[281] = 4184*(DP_[117]-273.15);
W_[287] = DP_[117]-273.15;
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[17] = 0;
W_[18] = 300000.0;
W_[26] = 0;
W_[27] = 300;
W_[29] = 300;
W_[69] = 0;
W_[99] = 288.15;
W_[103] = 0;
W_[111] = 0;
W_[150] = 0;
W_[157] = 0;
W_[245] = 1;
W_[249] = 300;
W_[255] = 300000.0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[19] = W_[85];
W_[102] = DP_[11];
W_[248] = DP_[114];
W_[321] = 4165531.824*W_[50]*(W_[62]-273.15);
InitialStartSection
Aux_[0] = W_[85];
Aux_[0] = W_[85];
InitialStartSection2
X_[4] = DP_[114];
X_[5] = W_[304];
X_[6] = W_[335];
X_[7] = W_[340];
Y_[0] = DP_[114];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
F_[0] = 0.0;
F_[2] = 0.0;
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[88] = 1.5E-006*DP_[23];
W_[35] = 0.1*W_[88]*W_[82];
W_[43] = DP_[10];
W_[44] = DP_[11];
W_[45] = DP_[12];
W_[50] = divmacro(10*W_[35],"10*boiler2WithControls.boi.boi.tau",W_[82],
  "boiler2WithControls.boi.boi.rho_default");
W_[61] = W_[43];
W_[62] = W_[44];
W_[79] = W_[34];
W_[74] = IF W_[81] AND W_[78] THEN 0.7853981633974483*W_[75]*DP_[19]*DP_[20]
   ELSE IF W_[81] THEN 10*W_[79] ELSE 0;
W_[83] = DP_[10];
W_[84] = DP_[11];
W_[85] = 4184*(W_[84]-273.15);
W_[87] = 0.0016666666666666668*DP_[23];
W_[89] = 0.0015*DP_[23];
W_[98] = W_[87];
W_[101] = 500*W_[89];
W_[113] = W_[124]+DP_[45];
W_[116] = 10*DP_[34];
W_[119] = fabs(W_[113]);
W_[132] = divmacro(5,"5",6.283185307179586*DP_[36],"6.283185307179586*boiler2WithControls.boi.valBoi.riseTime");
AssertModelica(W_[132] > 0,"boiler2WithControls.boi.valBoi.filter.f_cut > 0", 
  "f_cut > 0 required");
W_[135] = DP_[37];
W_[146] = IF DP_[45] > 1E-060 THEN divmacro(10,"10",sqrtGuarded(DP_[45],
  "boiler2WithControls.boi.valBoi.dpFixed_nominal"),"sqrt(boiler2WithControls.boi.valBoi.dpFixed_nominal)")
   ELSE 0;
W_[159] = W_[170]+DP_[63];
W_[162] = 10*DP_[52];
W_[165] = fabs(W_[159]);
W_[179] = divmacro(5,"5",6.283185307179586*DP_[54],"6.283185307179586*boiler2WithControls.boi.valByp.riseTime");
AssertModelica(W_[179] > 0,"boiler2WithControls.boi.valByp.filter.f_cut > 0", 
  "f_cut > 0 required");
W_[182] = DP_[55];
W_[193] = IF DP_[63] > 1E-060 THEN divmacro(10,"10",sqrtGuarded(DP_[63],
  "boiler2WithControls.boi.valByp.dpFixed_nominal"),"sqrt(boiler2WithControls.boi.valByp.dpFixed_nominal)")
   ELSE 0;
W_[231] = IF DP_[107] THEN -1 ELSE 1;
W_[218] = W_[231]*DP_[96];
W_[219] =  -W_[231];
W_[221] = DP_[91];
W_[225] = DP_[94];
W_[226] = DP_[95];
AssertModelica(W_[225] >= W_[226],"boiler2WithControls.bolCon.conPID.limiter.uMax >= boiler2WithControls.bolCon.conPID.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[225], true, 0)),") < uMin (="),Real2String2(W_[226], true, 0)),
  ")"));
PopAllMarks();
W_[303] = W_[43];
W_[304] = W_[44];
W_[305] = W_[45];
W_[329] = 4184*(W_[304]-273.15);
W_[331] = W_[231]*DP_[97];
W_[332] =  -W_[231];
W_[333] = divmacro(1,"1",DP_[92],"boiler2WithControls.bolCon.conPID.Ti");
W_[335] = DP_[100];
W_[337] = DP_[93];
W_[338] = RealBmax(divmacro(DP_[93],"boiler2WithControls.bolCon.conPID.Td",
  DP_[99],"boiler2WithControls.bolCon.conPID.Nd"), 1E-014);
W_[340] = DP_[101];
W_[342] = W_[231];
W_[343] =  -W_[231];
W_[346] = divmacro(1,"1",DP_[91]*DP_[98],"boiler2WithControls.bolCon.conPID.k*boiler2WithControls.bolCon.conPID.Ni");
W_[246] = W_[243] > 1E-010 OR W_[243] < -1E-010;
W_[341] = fabs(W_[337]) < 1E-015;
W_[125] = 0.0;
W_[121] = 0.0;
W_[122] = 0.0;
W_[123] = 0.0;
  {
    W_[125] = 1.0;
    W_[121] = divmacro(W_[125],"boiler2WithControls.boi.valBoi.Kv_SI",
      8.78410461157883E-007*DP_[35],"8.78410461157883E-007*boiler2WithControls.boi.valBoi.rhoStd");
    W_[122] = divmacro(W_[125],"boiler2WithControls.boi.valBoi.Kv_SI",
      1.2042949486827428E-005*DP_[35]*0.0631,"1.2042949486827428E-005*(boiler2WithControls.boi.valBoi.rhoStd*0.0631)");
    W_[123] = divmacro(W_[125],"boiler2WithControls.boi.valBoi.Kv_SI",
      sqrtGuarded(DP_[35],"boiler2WithControls.boi.valBoi.rhoStd"),
      "sqrt(boiler2WithControls.boi.valBoi.rhoStd)");
  }
RealAssign (RealTemporaryDense( &W_[140], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, boiler2WithControls.boi.valBoi.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[41])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(boiler2WithControls.boi.valBoi.filter.cr, boiler2WithControls.boi.valBoi.filter.c0, boiler2WithControls.boi.valBoi.filter.c1, boiler2WithControls.boi.valBoi.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[140], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[132]));
  RealAssign (RealTemporaryDense( &W_[142], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
W_[171] = 0.0;
W_[167] = 0.0;
W_[168] = 0.0;
W_[169] = 0.0;
  {
    W_[171] = 1.0;
    W_[167] = divmacro(W_[171],"boiler2WithControls.boi.valByp.Kv_SI",
      8.78410461157883E-007*DP_[53],"8.78410461157883E-007*boiler2WithControls.boi.valByp.rhoStd");
    W_[168] = divmacro(W_[171],"boiler2WithControls.boi.valByp.Kv_SI",
      1.2042949486827428E-005*DP_[53]*0.0631,"1.2042949486827428E-005*(boiler2WithControls.boi.valByp.rhoStd*0.0631)");
    W_[169] = divmacro(W_[171],"boiler2WithControls.boi.valByp.Kv_SI",
      sqrtGuarded(DP_[53],"boiler2WithControls.boi.valByp.rhoStd"),
      "sqrt(boiler2WithControls.boi.valByp.rhoStd)");
  }
RealAssign (RealTemporaryDense( &W_[187], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, boiler2WithControls.boi.valByp.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[59])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(boiler2WithControls.boi.valByp.filter.cr, boiler2WithControls.boi.valByp.filter.c0, boiler2WithControls.boi.valByp.filter.c1, boiler2WithControls.boi.valByp.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[187], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[179]));
  RealAssign (RealTemporaryDense( &W_[189], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
W_[209] = 0.0;
  {
    W_[209] = 1.0;
  }
W_[330] = W_[331]*DP_[90]+W_[332]*DP_[119];
W_[217] = W_[218]*DP_[90]+W_[219]*DP_[119];
W_[220] = DP_[103]*W_[217];
W_[200] = DP_[120];
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", boiler2WithControls.bolCon.combiTable1D.table, boiler2WithControls.bolCon.combiTable1D.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DP_[68], 2, 7, 3), IntegerTemporaryDense( &W_[205], 1, 2),
     1, 0, 1));
  W_[208] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
W_[199] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nboiler2WithControls.bolCon.combiTable1D.tableID, \n1, \nboiler2WithControls.bolCon.integerToReal.y, \nboiler2WithControls.bolCon.combiTable1D.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[208])), 1, W_[200], W_[209]));
PopModelContext();
W_[144] = divmacro(W_[199],"boiler2WithControls.boi.valCon",DP_[44],
  "boiler2WithControls.boi.valBoi.filter.u_nominal");
W_[174] = DP_[65]*W_[199]+DP_[66]*DP_[67];
W_[191] = divmacro(W_[174],"boiler2WithControls.boi.valByp.y",DP_[62],
  "boiler2WithControls.boi.valByp.filter.u_nominal");
W_[290] = 4184*(DP_[117]-273.15);
W_[203] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nboiler2WithControls.bolCon.combiTable1D.tableID, \n2, \nboiler2WithControls.bolCon.integerToReal.y, \nboiler2WithControls.bolCon.combiTable1D.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[208])), 2, W_[200], W_[209]));
PopModelContext();
W_[323] = 995.586*W_[50];
W_[268] = 4184*(DP_[115]-273.15);
W_[250] = 273.15+0.0002390057361376673*W_[290];
W_[276] = DP_[116];
W_[298] = DP_[118];
InitialSection
Aux_[6] = W_[268];
Aux_[7] = W_[290];
InitialSection2
 /* Linear system of equations to solve. */
W_[95] = 0.0;
SolveScalarLinearParametric( -W_[98]," -boiler2WithControls.boi.boi.UAOve.G", 
  0.0,"0.0", W_[95],"boiler2WithControls.boi.boi.UAOve.dT");
 /* End of Equation Block */ 

W_[211] = DP_[90]-DP_[119];
W_[260] = 4184*(DP_[115]-273.15);
W_[265] = DP_[115]-273.15;
W_[281] = 4184*(DP_[117]-273.15);
W_[287] = DP_[117]-273.15;
X_[7] = W_[340];
X_[6] = W_[335];
 /* Linear system of equations to solve. */
X_[0] = 0.0;
SolveScalarLinearParametric( -W_[142]," -boiler2WithControls.boi.valBoi.filter.r[1]",
    -W_[142]*W_[144]," -boiler2WithControls.boi.valBoi.filter.r[1]*boiler2WithControls.boi.valBoi.filter.uu[1]",
   X_[0],"boiler2WithControls.boi.valBoi.filter.x[1]");
 /* End of Equation Block */ 

W_[128] = W_[135];
 /* Linear system of equations to solve. */
X_[1] = 0.0;
SolveScalarLinearParametric( -DP_[38]*DP_[44]," -boiler2WithControls.boi.valBoi.filter.gain*boiler2WithControls.boi.valBoi.filter.u_nominal",
    -W_[128]," -boiler2WithControls.boi.valBoi.y_actual", X_[1],"boiler2WithControls.boi.valBoi.filter.x[2]");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
X_[2] = 0.0;
SolveScalarLinearParametric( -W_[189]," -boiler2WithControls.boi.valByp.filter.r[1]",
    -W_[189]*W_[191]," -boiler2WithControls.boi.valByp.filter.r[1]*boiler2WithControls.boi.valByp.filter.uu[1]",
   X_[2],"boiler2WithControls.boi.valByp.filter.x[1]");
 /* End of Equation Block */ 

W_[175] = W_[182];
 /* Linear system of equations to solve. */
X_[3] = 0.0;
SolveScalarLinearParametric( -DP_[56]*DP_[62]," -boiler2WithControls.boi.valByp.filter.gain*boiler2WithControls.boi.valByp.filter.u_nominal",
    -W_[175]," -boiler2WithControls.boi.valByp.y_actual", X_[3],"boiler2WithControls.boi.valByp.filter.x[2]");
 /* End of Equation Block */ 

X_[5] = W_[304];
AssertModelica(GreaterEqual(X_[5],"boiler2WithControls.boi.boi.vol.dynBal.medium.T",
   272.15,"272.15", 0) AND LessEqual(X_[5],"boiler2WithControls.boi.boi.vol.dynBal.medium.T",
   403.15,"403.15", 1),"boiler2WithControls.boi.boi.vol.dynBal.medium.T >= 272.15 and boiler2WithControls.boi.boi.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[5], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
X_[4] = DP_[114];
W_[145] = DP_[46]+W_[128]*(1-DP_[46]);
W_[147] = W_[145]*W_[125];
W_[148] = IF DP_[45] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[146]),"boiler2WithControls.boi.valBoi.kFixed^2")+divmacro(1,"1",sqr(
  W_[147]),"boiler2WithControls.boi.valBoi.kVal^2"),"1/boiler2WithControls.boi.valBoi.kFixed^2+1/boiler2WithControls.boi.valBoi.kVal^2"),
  "1/(1/boiler2WithControls.boi.valBoi.kFixed^2+1/boiler2WithControls.boi.valBoi.kVal^2)")
   ELSE W_[147];
W_[192] = DP_[64]+W_[175]*(1-DP_[64]);
W_[194] = W_[192]*W_[171];
W_[195] = IF DP_[63] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[193]),"boiler2WithControls.boi.valByp.kFixed^2")+divmacro(1,"1",sqr(
  W_[194]),"boiler2WithControls.boi.valByp.kVal^2"),"1/boiler2WithControls.boi.valByp.kFixed^2+1/boiler2WithControls.boi.valByp.kVal^2"),
  "1/(1/boiler2WithControls.boi.valByp.kFixed^2+1/boiler2WithControls.boi.valByp.kVal^2)")
   ELSE W_[194];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(3);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 1. */
  /* Introducing 7 common subexpressions used in 10 expressions */
  /* Of the common subexpressions 7 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"boiler2WithControls.boi.valByp.port_a.m_flow"};
  const double nominal_[]={10.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 1, 7);
  SetInitVectorSimple(x__, 1, W_[150], 0);
  Residues;
    W_[17] = 10.0-W_[150];
    W_[69] = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.boi.port_a.m_flow, 1.0, 1.0)")
      Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[17],
       1.0, 1.0)), 10.0*W_[17]);
    PopModelContext();
    W_[18] = 100.0+W_[69];
    W_[111] = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.boi.port_a.m_flow, boiler2WithControls.boi.valBoi.k, boiler2WithControls.boi.valBoi.m_flow_turbulent)")
      Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[17],
       W_[148], W_[116])), 0.1*W_[119]*W_[17]);
    PopModelContext();
    W_[255] = W_[111]+W_[18];
    W_[157] = W_[255]-100.0;
  SetVector(residue__, 1, W_[157]-homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.valByp.port_a.m_flow, boiler2WithControls.boi.valByp.k, boiler2WithControls.boi.valByp.m_flow_turbulent)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[150],
     W_[195], W_[162])), 0.1*W_[165]*W_[150]));
  PopModelContext();

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  helpvar[2] = homotopy(0.0, 0.0);
  helpvar[3] = 1.0-3.0*helpvar[2];
  helpvar[4] = helpvar[2]*helpvar[3];
  helpvar[5] = 2.0*helpvar[2];
  helpvar[6] = helpvar[4]-helpvar[2]+1.0-helpvar[5]-helpvar[2]+helpvar[4];
  helpvar[7] = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.boi.port_a.m_flow, 1.0, 1.0, 1.0, 0.0, 0.0)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
    W_[17], 1.0, 1.0, 1.0, 0.0, 0.0)), 10.0)*helpvar[6]-helpvar[2];
  PopModelContext();
  helpvar[8] = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.boi.port_a.m_flow, boiler2WithControls.boi.valBoi.k, boiler2WithControls.boi.valBoi.m_flow_turbulent, 1.0, 0.0, 0.0)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
    W_[17], W_[148], W_[116], 1.0, 0.0, 0.0)), 0.1*W_[119])*helpvar[3];
  PopModelContext();
  SetMatrixLeading(Jacobian__, 1, 1, 1, (-1.0)*(helpvar[7]+helpvar[8]-helpvar[6]
    *helpvar[2]-helpvar[4])-homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.valByp.port_a.m_flow, boiler2WithControls.boi.valByp.k, boiler2WithControls.boi.valByp.m_flow_turbulent, 1.0, 0.0, 0.0)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
    W_[150], W_[195], W_[162], 1.0, 0.0, 0.0)), 0.1*W_[165]));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[150] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



}
AssertModelica(GreaterEqual(W_[255],"boiler2WithControls.port_a1.p", 0.0,"0.0", 2),
  "boiler2WithControls.port_a1.p >= 0.0", StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(W_[255], true, 0)),
  " Pa) of medium \""),"SimpleLiquidWater"),"\" is negative\n(Temperature = "),
  Real2String2(DP_[115], true, 0))," K)"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
InitialSection
Init=false;InitializeData(2);Init=true;
InitialSection2
  AssertModelica(W_[35] > 1E-015,"boiler2WithControls.boi.boi.tau > 1E-015", 
    StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(W_[35], true, 0)),"\n"));
  PopAllMarks();
  AssertModelica(W_[35] > 1E-015,"boiler2WithControls.boi.boi.tau > 1E-015", 
    StringAdd(StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.          \n You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(W_[35], true, 0)),"\n"));
  PopAllMarks();
AssertModelica(DP_[25] > 0.001,"boiler2WithControls.boi.boi.a[1] > 0.001", 
  "Efficiency curve is wrong.");
EndInitialSection

OutputSection
AssertModelica(GreaterEqual(X_[5],"boiler2WithControls.boi.boi.vol.dynBal.medium.T",
   272.15,"272.15", 0) AND LessEqual(X_[5],"boiler2WithControls.boi.boi.vol.dynBal.medium.T",
   403.15,"403.15", 1),"boiler2WithControls.boi.boi.vol.dynBal.medium.T >= 272.15 and boiler2WithControls.boi.boi.vol.dynBal.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(X_[5], true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
PopAllMarks();
Y_[0] = X_[4];
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, boundary.X_in_internal, \"MassFlowSource_T\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[276], 1, 1), 
  "MassFlowSource_T"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, bou1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[298], 1, 1), 
  "Boundary_pT"));
PopAllMarks();

DynamicsSection
F_[7] = IF W_[341] THEN 0 ELSE divmacro(W_[330]-X_[7],"boiler2WithControls.bolCon.conPID.addD.y-boiler2WithControls.bolCon.conPID.D.x",
  W_[338],"boiler2WithControls.bolCon.conPID.D.T");
W_[224] = IF W_[341] THEN 0 ELSE divmacro(W_[337]*(W_[330]-X_[7]),
  "boiler2WithControls.bolCon.conPID.D.k*(boiler2WithControls.bolCon.conPID.addD.y-boiler2WithControls.bolCon.conPID.D.x)",
  W_[338],"boiler2WithControls.bolCon.conPID.D.T");
W_[222] = DP_[104]*W_[220]+DP_[105]*W_[224]+DP_[106]*X_[6];
W_[223] = W_[221]*W_[222];
W_[210] = IF GreaterS(W_[223],"boiler2WithControls.bolCon.conPID.gainPID.y", 
  W_[225],"boiler2WithControls.bolCon.conPID.limiter.uMax", 3) THEN W_[225]
   ELSE IF LessS(W_[223],"boiler2WithControls.bolCon.conPID.gainPID.y", W_[226],
  "boiler2WithControls.bolCon.conPID.limiter.uMin", 4) THEN W_[226] ELSE W_[223];
W_[345] = DP_[124]*W_[210]+DP_[125]*W_[223];
W_[344] = W_[346]*W_[345];
W_[336] = W_[342]*DP_[90]+W_[343]*DP_[119]+DP_[123]*W_[344];
F_[6] = W_[333]*W_[336];
F_[0] = W_[142]*(X_[0]-W_[144]);
F_[1] = W_[143]*(X_[1]-X_[0]);
F_[2] = W_[189]*(X_[2]-W_[191]);
F_[3] = W_[190]*(X_[3]-X_[2]);
W_[128] = DP_[38]*DP_[44]*X_[1];
W_[145] = DP_[46]+W_[128]*(1-DP_[46]);
W_[147] = W_[145]*W_[125];
W_[148] = IF DP_[45] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[146]),"boiler2WithControls.boi.valBoi.kFixed^2")+divmacro(1,"1",sqr(
  W_[147]),"boiler2WithControls.boi.valBoi.kVal^2"),"1/boiler2WithControls.boi.valBoi.kFixed^2+1/boiler2WithControls.boi.valBoi.kVal^2"),
  "1/(1/boiler2WithControls.boi.valBoi.kFixed^2+1/boiler2WithControls.boi.valBoi.kVal^2)")
   ELSE W_[147];
W_[175] = DP_[56]*DP_[62]*X_[3];
W_[192] = DP_[64]+W_[175]*(1-DP_[64]);
W_[194] = W_[192]*W_[171];
W_[195] = IF DP_[63] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[193]),"boiler2WithControls.boi.valByp.kFixed^2")+divmacro(1,"1",sqr(
  W_[194]),"boiler2WithControls.boi.valByp.kVal^2"),"1/boiler2WithControls.boi.valByp.kFixed^2+1/boiler2WithControls.boi.valByp.kVal^2"),
  "1/(1/boiler2WithControls.boi.valByp.kFixed^2+1/boiler2WithControls.boi.valByp.kVal^2)")
   ELSE W_[194];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 2. */
/* Introducing 7 common subexpressions and reusing 1 variables totally used in 0
   expressions */
/* Of the common subexpressions 8 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"boiler2WithControls.boi.boi.port_a.p", 
  "boiler2WithControls.boi.valByp.port_a.m_flow"};
const double nominal_[]={300000.0, 10.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 2, 8, 2);
NonLinearSystemSave(W_[148], 0);
NonLinearSystemSave(W_[195], 1);
SetInitVectorNH(x__, 1, W_[18], Remember_(W_[18], 0));
SetInitVectorNH(x__, 2, W_[150], Remember_(W_[150], 1));
Residues;
  W_[69] = W_[18]-100.0;
  W_[17] = 10.0-W_[150];
  W_[111] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.boi.port_a.m_flow, boiler2WithControls.boi.valBoi.k, boiler2WithControls.boi.valBoi.m_flow_turbulent)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[17], 
    W_[148], W_[116]));
  PopModelContext();
  W_[255] = W_[111]+W_[18];
  W_[157] = W_[255]-100.0;
helpvar[9] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.boi.port_a.m_flow, 1.0, 1.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[17], 
  1.0, 1.0));
PopModelContext();
helpvar[10] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(boiler2WithControls.boi.valByp.port_a.m_flow, boiler2WithControls.boi.valByp.k, boiler2WithControls.boi.valByp.m_flow_turbulent)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[150], 
  W_[195], W_[162]));
PopModelContext();
SetVector(residue__, 1, W_[69]-helpvar[9]);
SetVector(residue__, 2, W_[157]-helpvar[10]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 2, 1.0);
SetMatrixLeading(Jacobian__, 1, 2, 2, (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.boi.port_a.m_flow, 1.0, 1.0, 1.0, 0.0, 0.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
  W_[17], 1.0, 1.0, 1.0, 0.0, 0.0)));
PopModelContext();
SetMatrixLeading(Jacobian__, 2, 1, 2, 1.0);
SetMatrixLeading(Jacobian__, 2, 2, 2, (-1.0)*(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.boi.port_a.m_flow, boiler2WithControls.boi.valBoi.k, boiler2WithControls.boi.valBoi.m_flow_turbulent, 1.0, 0.0, 0.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
  W_[17], W_[148], W_[116], 1.0, 0.0, 0.0))-(PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:derf(boiler2WithControls.boi.valByp.port_a.m_flow, boiler2WithControls.boi.valByp.k, boiler2WithControls.boi.valByp.m_flow_turbulent, 1.0, 0.0, 0.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__derf(
  W_[150], W_[195], W_[162], 1.0, 0.0, 0.0)));
PopModelContext();

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2);
W_[18] = GetVector(x__, 1);
W_[150] = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunctionEnd()
BreakSectionFunctionStart(6);
helpvar[11] = RealBmax( -W_[150], 0.0);
Aux_[16] = 10.0+helpvar[11];
Aux_[17] = IF Aux_[16] > 1E-010 THEN 1.0 ELSE IF Aux_[16] > 0.0 THEN sqr(
  10000000000.0*Aux_[16])*(3.0-20000000000.0*Aux_[16]) ELSE 0.0;
W_[21] =  -(DP_[13]+W_[17]);
W_[251] = W_[21]-W_[150];
helpvar[12] = RealBmax(W_[251], 0.0);
helpvar[13] = RealBmax( -W_[21], 0.0);
Aux_[14] = helpvar[12]+helpvar[13];
Aux_[15] = IF Aux_[14] > 1E-010 THEN 1.0 ELSE IF Aux_[14] > 0.0 THEN sqr(
  10000000000.0*Aux_[14])*(3.0-20000000000.0*Aux_[14]) ELSE 0.0;
W_[19] = 4184*(X_[5]-273.15);
helpvar[14] = 1.0-Aux_[15];
helpvar[15] = 1E-010*helpvar[14];
helpvar[16] = Aux_[15]*helpvar[12]+helpvar[15];
helpvar[17] = Aux_[15]*helpvar[13]+helpvar[15];
helpvar[18] = helpvar[16]+helpvar[17];
helpvar[19] = divmacro(1.0,"1.0",helpvar[18],"stream_alpha5*max(boiler2WithControls.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)+stream_alpha5*max( -boiler2WithControls.boi.boi.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)");
W_[151] = helpvar[19]*(helpvar[16]*W_[290]+helpvar[17]*W_[19]);
helpvar[20] = 1.0-Aux_[17];
helpvar[21] = Aux_[17]*helpvar[11]+1E-010*helpvar[20];
helpvar[22] = 10.0+helpvar[21];
helpvar[23] = divmacro(1.0,"1.0",helpvar[22],"10.0+stream_alpha7*max( -boiler2WithControls.boi.valByp.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha7)");
W_[107] = helpvar[23]*(helpvar[21]*W_[151]+10.0*W_[268]);
W_[326] = W_[17]*(IF W_[17] > 0.0 THEN W_[107] ELSE W_[19]);
helpvar[24] = RealBmax(W_[150], 0.0);
Aux_[12] = helpvar[12]+helpvar[24];
Aux_[13] = IF Aux_[12] > 1E-010 THEN 1.0 ELSE IF Aux_[12] > 0.0 THEN sqr(
  10000000000.0*Aux_[12])*(3.0-20000000000.0*Aux_[12]) ELSE 0.0;
helpvar[25] = RealBmax( -W_[17], 0.0);
Aux_[10] = 10.0+helpvar[25];
Aux_[11] = IF Aux_[10] > 1E-010 THEN 1.0 ELSE IF Aux_[10] > 0.0 THEN sqr(
  10000000000.0*Aux_[10])*(3.0-20000000000.0*Aux_[10]) ELSE 0.0;
helpvar[26] = 1.0-Aux_[11];
helpvar[27] = Aux_[11]*helpvar[25]+1E-010*helpvar[26];
helpvar[28] = 10.0+helpvar[27];
helpvar[29] = divmacro(1.0,"1.0",helpvar[28],"10.0+stream_alpha1*max( -boiler2WithControls.boi.boi.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
W_[153] = helpvar[29]*(helpvar[27]*W_[19]+10.0*W_[268]);
helpvar[30] = 1.0-Aux_[13];
helpvar[31] = 1E-010*helpvar[30];
helpvar[32] = Aux_[13]*helpvar[12]+helpvar[31];
helpvar[33] = Aux_[13]*helpvar[24]+helpvar[31];
helpvar[34] = helpvar[32]+helpvar[33];
helpvar[35] = divmacro(1.0,"1.0",helpvar[34],"stream_alpha3*max(boiler2WithControls.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max(boiler2WithControls.boi.valByp.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
Aux_[0] = helpvar[35]*(helpvar[32]*W_[290]+helpvar[33]*W_[153]);
Aux_[1] = Aux_[0];
Aux_[9] = Aux_[1];
W_[327] = W_[21]*(IF W_[21] > 0.0 THEN Aux_[9] ELSE W_[19]);
W_[325] = W_[326]+W_[327];
W_[198] = W_[203]*W_[210];
W_[90] = divmacro(W_[198]*DP_[23],"boiler2WithControls.boi.boiCon*boiler2WithControls.boi.boi.Q_flow_nominal",
  DP_[25],"boiler2WithControls.boi.boi.a[1]");
W_[91] = DP_[25]*W_[90];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(7);
 /* Linear system of equations to solve. */
/* Introducing 0 common subexpressions and reusing 1 variables totally used in 1
   expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
F_[5] = RememberSimple_(F_[5], 2);
SolveScalarLinearParametric(4184.0*W_[323]+W_[101],"4184.0*boiler2WithControls.boi.boi.vol.dynBal.m+boiler2WithControls.boi.boi.heaCapDry.C",
   W_[91]+W_[325],"boiler2WithControls.boi.boi.QWat_flow+boiler2WithControls.boi.boi.vol.dynBal.Hb_flow",
   F_[5],"der(boiler2WithControls.boi.boi.vol.dynBal.medium.T)");
W_[313] = 4184*F_[5];
W_[322] = W_[323]*W_[313];
W_[20] = W_[313];
W_[103] = 0.0002390057361376673*W_[20];
W_[104] = W_[101]*W_[103];
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(8);
W_[54] = W_[322]-W_[325];
Aux_[18] = helpvar[24]+helpvar[13];
Aux_[19] = IF Aux_[18] > 1E-010 THEN 1.0 ELSE IF Aux_[18] > 0.0 THEN sqr(
  10000000000.0*Aux_[18])*(3.0-20000000000.0*Aux_[18]) ELSE 0.0;
helpvar[36] = 1.0-Aux_[19];
helpvar[37] = 1E-010*helpvar[36];
helpvar[38] = Aux_[19]*helpvar[24]+helpvar[37];
helpvar[39] = Aux_[19]*helpvar[13]+helpvar[37];
helpvar[40] = helpvar[38]+helpvar[39];
helpvar[41] = divmacro(1.0,"1.0",helpvar[40],"stream_alpha9*max(boiler2WithControls.boi.valByp.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha9)+stream_alpha9*max( -boiler2WithControls.boi.boi.port_b.m_flow, 0.0)+1E-010*(1.0-stream_alpha9)");
W_[253] = helpvar[41]*(helpvar[38]*W_[153]+helpvar[39]*W_[19]);
W_[249] = 273.15+0.0002390057361376673*W_[253];
W_[248] = IF  -W_[251] > 0.001 THEN W_[249] ELSE IF  -W_[251] < -0.001 THEN 
  W_[250] ELSE 0.5*(W_[249]+W_[250])-250.0*W_[251]*(sqr((-1000.0)*W_[251])-3)*(
  W_[250]-W_[249]);
W_[247] = (-0.1)*W_[251];
W_[245] = IF  -W_[251] > 0.001 THEN W_[247] ELSE IF  -W_[251] < -0.001 THEN  -
  W_[247] ELSE 500.0*W_[251]*(sqr((-1000.0)*W_[251])-3)*W_[247];
F_[4] = (W_[248]-X_[4])*W_[245];
AssertModelica(GreaterEqual(W_[255],"boiler2WithControls.port_a1.p", 0.0,"0.0", 2),
  "boiler2WithControls.port_a1.p >= 0.0", StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(W_[255], true, 0)),
  " Pa) of medium \""),"SimpleLiquidWater"),"\" is negative\n(Temperature = "),
  Real2String2(DP_[115], true, 0))," K)"));
PopAllMarks();

AcceptedSection1

AcceptedSection2
Aux_[4] = W_[153];
Aux_[5] = W_[151];
Aux_[3] = W_[107];
Aux_[8] = W_[107];
Aux_[2] = W_[107];
W_[312] = 4184*(X_[5]-273.15);
W_[321] = W_[323]*W_[312];
W_[102] = 273.15+0.0002390057361376673*W_[19];
W_[26] = W_[18]-100.0;
W_[27] = 273.15+0.0002390057361376673*(IF W_[17] > 0.0 THEN W_[107] ELSE W_[19]);
W_[29] = 273.15+0.0002390057361376673*(IF W_[21] > 0.0 THEN Aux_[0] ELSE W_[19]);
W_[92] = divmacro(W_[90],"boiler2WithControls.boi.boi.QFue_flow",DP_[26],
  "boiler2WithControls.boi.boi.fue.h");
W_[93] = divmacro(W_[92],"boiler2WithControls.boi.boi.mFue_flow",DP_[27],
  "boiler2WithControls.boi.boi.fue.d");
W_[99] = W_[95]+W_[102];
Aux_[20] = helpvar[11]+helpvar[25];
Aux_[21] = IF Aux_[20] > 1E-010 THEN 1.0 ELSE IF Aux_[20] > 0.0 THEN sqr(
  10000000000.0*Aux_[20])*(3.0-20000000000.0*Aux_[20]) ELSE 0.0;
helpvar[42] = 1.0-Aux_[21];
helpvar[43] = 1E-010*helpvar[42];
helpvar[44] = Aux_[21]*helpvar[11]+helpvar[43];
helpvar[45] = Aux_[21]*helpvar[25]+helpvar[43];
helpvar[46] = helpvar[44]+helpvar[45];
helpvar[47] = divmacro(1.0,"1.0",helpvar[46],"stream_alpha11*max( -boiler2WithControls.boi.valByp.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha11)+stream_alpha11*max( -boiler2WithControls.boi.boi.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha11)");
W_[256] = helpvar[47]*(helpvar[44]*W_[151]+helpvar[45]*W_[19]);
W_[266] = 1E-005*W_[255];
W_[319] = X_[5]-273.15;

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
283.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", \
0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal",\
 4, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 5, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 6, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("dp_nominal", "Nominal pressure difference [Pa|bar]", 100, \
0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.dp_nominal", "Nominal pressure difference [Pa|bar]",\
 100, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.mWater_flow_nominal", "Nominal mass flow rate of water [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.dp_nominal", "Nominal pressure difference [Pa|bar]",\
 100, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,10.0,0,776)
DeclareVariable("boiler2WithControls.boi.boi.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,300000.0,0,520)
DeclareVariable("boiler2WithControls.boi.boi.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("boiler2WithControls.boi.boi.port_a.der(h_outflow)", \
"der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("boiler2WithControls.boi.boi.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,776)
DeclareVariable("boiler2WithControls.boi.boi.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,300000.0,0,521)
DeclareAlias2("boiler2WithControls.boi.boi.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 4)
DeclareParameter("boiler2WithControls.boi.boi.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 7, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.boi.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 8, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.boi.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 9, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.boi.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.boi.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 0)
DeclareVariable("boiler2WithControls.boi.boi.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.boi.boi.sta_a.p", "Absolute pressure of medium [Pa|bar]",\
 "boiler2WithControls.boi.boi.port_a.p", 1, 5, 18, 0)
DeclareVariable("boiler2WithControls.boi.boi.sta_a.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.sta_b.p", "Absolute pressure of medium [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.sta_b.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.computeFlowResistance", \
"=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.dp_nominal", "Pressure [Pa|Pa]", 100,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.linearizeFlowResistance", \
"= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("boiler2WithControls.boi.boi.p_start", "Start value of pressure [Pa|bar]",\
 10, 300000.0, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.T_start", "Start value of temperature [K|degC]",\
 11, 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 12, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("boiler2WithControls.boi.boi.vol.energyDynamics", \
"Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.vol.substanceDynamics", \
"Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, \
1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.vol.traceDynamics", \
"Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.vol.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.boi.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.allowFlowReversal", \
"= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.vol.V", "Volume [m3]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.boi.vol.ports[1].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 132)
DeclareVariable("boiler2WithControls.boi.boi.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("boiler2WithControls.boi.boi.vol.ports[1].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 4)
DeclareAlias2("boiler2WithControls.boi.boi.vol.ports[2].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_b.m_flow", 1, 5, 21, 132)
DeclareVariable("boiler2WithControls.boi.boi.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("boiler2WithControls.boi.boi.vol.ports[2].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 4)
DeclareAlias2("boiler2WithControls.boi.boi.vol.heatPort.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 4)
DeclareVariable("boiler2WithControls.boi.boi.vol.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("boiler2WithControls.boi.boi.vol.T", "Temperature of the fluid [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 0)
DeclareVariable("boiler2WithControls.boi.boi.vol.p", "Pressure of the fluid [Pa|bar]",\
 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1.0,\
 0.0,1.0,0.1,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.state_default.p", \
"Absolute pressure of medium [Pa|bar]", 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.state_default.T", \
"Temperature of medium [K|degC]", 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.state_start.p", \
"Absolute pressure of medium [Pa|bar]", 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.state_start.T", \
"Temperature of medium [K|degC]", 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.useSteadyStateTwoPort", \
"Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("boiler2WithControls.boi.boi.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.vol.QSen_flow.y", "Value of Real output [W]",\
 "boiler2WithControls.boi.boi.vol.heatPort.Q_flow", 1, 5, 54, 1024)
DeclareParameter("boiler2WithControls.boi.boi.vol.masExc.k", "Constant output value [kg/s]",\
 13, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("boiler2WithControls.boi.boi.vol.masExc.y", "Connector of Real output signal [kg/s]",\
 "boiler2WithControls.boi.boi.vol.masExc.k", 1, 7, 13, 1024)
DeclareVariable("boiler2WithControls.boi.boi.preDro.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.port_a.m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 132)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.boi.boi.port_a.p", 1, 5, 18, 4)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.port_a.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 4)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.port_b.m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_a.m_flow", -1, 5, 17, 132)
DeclareVariable("boiler2WithControls.boi.boi.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,300000.0,0,521)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.port_b.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.valBoi.port_b.h_outflow", 1, 5, 107, 4)
DeclareParameter("boiler2WithControls.boi.boi.preDro.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 14, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.boi.preDro.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 15,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.boi.preDro.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 16, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.boi.preDro.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.preDro.m_flow_small", \
"Small mass flow rate for regularization of zero flow [kg/s]", 0.001, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.boi.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 0)
DeclareVariable("boiler2WithControls.boi.boi.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,100.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.preDro.dp_nominal", \
"Pressure drop at nominal mass flow rate [Pa|Pa]", 100, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.preDro.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.preDro.linearized", \
"= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.boi.preDro.m_flow_turbulent", \
"Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]", 1.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.boi.preDro.sta_default.p", \
"Absolute pressure of medium [Pa|bar]", 17, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("boiler2WithControls.boi.boi.preDro.sta_default.T", \
"Temperature of medium [K|degC]", 18, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("boiler2WithControls.boi.boi.preDro.eta_default", \
"Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.preDro.m_flow_nominal_pos", \
"Absolute value of nominal flow rate [kg/s]", 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.preDro.dp_nominal_pos", \
"Absolute value of nominal pressure [Pa|bar]", 100, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.preDro.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("boiler2WithControls.boi.boi.preDro.dh", "Hydraulic diameter [m]",\
 19, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.preDro.ReC", "Reynolds number where transition to turbulent starts",\
 20, 4000, 0.0,1E+100,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.boi.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.1, 0.01,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.preDro.computeFlowResistance", \
"Flag to enable/disable computation of flow resistance [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,2563)
DeclareParameter("boiler2WithControls.boi.boi.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 21, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("boiler2WithControls.boi.boi.sta_default.T", "Temperature of medium [K|degC]",\
 22, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("boiler2WithControls.boi.boi.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.sta_start.T", "Temperature of medium [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.boi.boi.Q_flow_nominal", "Nominal heating power [W]",\
 23, 2000000, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.T_nominal", "Temperature used to compute nominal efficiency (only used if efficiency curve depends on temperature) [K|degC]",\
 24, 353.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("boiler2WithControls.boi.boi.effCur", "Curve used to compute the efficiency [:#(type=Buildings.Fluid.Types.EfficiencyCurves)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("boiler2WithControls.boi.boi.a[1]", "Coefficients for efficiency curve",\
 25, 0.9, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.fue.h", "Heating value (lower or upper, depending on fuel) [J/kg]",\
 26, 50000000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.fue.d", "Mass density [kg/m3|g/cm3]",\
 27, 0.84, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.boi.fue.mCO2", "CO2 emission at combustion, in kg/kg fuel",\
 28, 2.23, 0.0,1E+100,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.boi.UA", "Overall UA value [W/K]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.VWat", "Water volume of boiler [m3]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.mDry", "Mass of boiler that will be lumped to water heat capacity [kg]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("boiler2WithControls.boi.boi.eta", "Boiler efficiency [1]", \
"boiler2WithControls.boi.boi.a[1]", 1, 7, 25, 0)
DeclareVariable("boiler2WithControls.boi.boi.QFue_flow", "Heat released by fuel [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.QWat_flow", "Heat transfer from gas into water [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.mFue_flow", "Fuel mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.VFue_flow", "Fuel volume flow rate [m3/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.boi.boi.y", "Part load ratio", \
"boiler2WithControls.boi.boiCon", 1, 5, 198, 0)
DeclareAlias2("boiler2WithControls.boi.boi.eta_nominal", "Boiler efficiency at nominal condition",\
 "boiler2WithControls.boi.boi.a[1]", 1, 7, 25, 1024)
DeclareVariable("boiler2WithControls.boi.boi.UAOve.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.UAOve.dT", "port_a.T - port_b.T [K,]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.boi.UAOve.port_a.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heatPort.T", 1, 5, 99, 1028)
DeclareVariable("boiler2WithControls.boi.boi.UAOve.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("boiler2WithControls.boi.boi.UAOve.port_b.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 1028)
DeclareVariable("boiler2WithControls.boi.boi.UAOve.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("boiler2WithControls.boi.boi.UAOve.G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.heatPort.T", "Port temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,520)
DeclareVariable("boiler2WithControls.boi.boi.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("boiler2WithControls.boi.boi.heaCapDry.C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.boi.heaCapDry.T", "Temperature of element [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,512)
DeclareVariable("boiler2WithControls.boi.boi.heaCapDry.der(T)", "der(Temperature of element) [K/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.boi.boi.heaCapDry.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "boiler2WithControls.boi.boi.heaCapDry.der(T)", 1, 5, 103, 0)
DeclareAlias2("boiler2WithControls.boi.boi.heaCapDry.port.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 4)
DeclareVariable("boiler2WithControls.boi.boi.heaCapDry.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("boiler2WithControls.boi.boi.T", "[K|degC]", "boiler2WithControls.boi.boi.heaCapDry.T", 1,\
 5, 102, 0)
DeclareAlias2("boiler2WithControls.boi.boi.preHeaFlo.Q_flow", "[W]", \
"boiler2WithControls.boi.boi.QWat_flow", 1, 5, 91, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.preHeaFlo.port.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 1028)
DeclareAlias2("boiler2WithControls.boi.boi.preHeaFlo.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"boiler2WithControls.boi.boi.QWat_flow", -1, 5, 91, 1156)
DeclareAlias2("boiler2WithControls.boi.boi.Q_flow_in.y", "Value of Real output [W]",\
 "boiler2WithControls.boi.boi.QWat_flow", 1, 5, 91, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.temSen.T", "Absolute temperature as output signal [K]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.temSen.port.T", "Port temperature [K|degC]",\
 "boiler2WithControls.boi.boi.heaCapDry.T", 1, 5, 102, 1028)
DeclareVariable("boiler2WithControls.boi.boi.temSen.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareVariable("boiler2WithControls.boi.valBoi.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.valBoi.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 132)
DeclareAlias2("boiler2WithControls.boi.valBoi.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareAlias2("boiler2WithControls.boi.valBoi.port_a.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 4)
DeclareAlias2("boiler2WithControls.boi.valBoi.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.boi.boi.port_a.m_flow", -1, 5, 17, 132)
DeclareAlias2("boiler2WithControls.boi.valBoi.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.boi.boi.port_a.p", 1, 5, 18, 4)
DeclareVariable("boiler2WithControls.boi.valBoi.port_b.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("boiler2WithControls.boi.valBoi.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 29, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.valBoi.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 30,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.valBoi.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 31, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.valBoi.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valBoi.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valBoi.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.valBoi.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 0)
DeclareVariable("boiler2WithControls.boi.valBoi.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("boiler2WithControls.boi.valBoi.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valBoi.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valBoi.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valBoi.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valBoi.m_flow_turbulent", \
"Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valBoi.sta_default.p", \
"Absolute pressure of medium [Pa|bar]", 32, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valBoi.sta_default.T", \
"Temperature of medium [K|degC]", 33, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("boiler2WithControls.boi.valBoi.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.m_flow_nominal_pos", \
"Absolute value of nominal flow rate [kg/s]", 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.dp_nominal_pos", \
"Absolute value of nominal pressure [Pa|bar]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.CvData", "Selection of flow coefficient [:#(type=Buildings.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.valBoi.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valBoi.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valBoi.Av", "Av (metric) flow coefficient [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valBoi.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 34, 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valBoi.dpValve_nominal", \
"Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 100, 1E-060,1E+100,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valBoi.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 35, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valBoi.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.filteredOpening", \
"= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("boiler2WithControls.boi.valBoi.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 36, 120, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valBoi.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("boiler2WithControls.boi.valBoi.y_start", "Initial value of output",\
 37, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.boi.valBoi.y", "Actuator position (0: closed, 1: open)",\
 "boiler2WithControls.boi.valCon", 1, 5, 199, 0)
DeclareVariable("boiler2WithControls.boi.valBoi.y_actual", "Actual valve position",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.boi.valBoi.y_filtered", "Filtered valve position in the range 0..1",\
 "boiler2WithControls.boi.valBoi.y_actual", 1, 5, 128, 1024)
DeclareAlias2("boiler2WithControls.boi.valBoi.filter.u", "Connector of Real input signal",\
 "boiler2WithControls.boi.valCon", 1, 5, 199, 1024)
DeclareAlias2("boiler2WithControls.boi.valBoi.filter.y", "Connector of Real output signal",\
 "boiler2WithControls.boi.valBoi.y_actual", 1, 5, 128, 1024)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.analogFilter", \
"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.filterType", \
"Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.order", "Order of filter [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.f_cut", "Cut-off frequency [Hz]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 38, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.A_ripple", \
"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 39, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 40, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.normalized", \
"= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 41, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.nx", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.x_start[1]", \
"Initial or guess values of states", 42, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.x_start[2]", \
"Initial or guess values of states", 43, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.y_start", \
"Initial value of output", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.boi.valBoi.filter.u_nominal", \
"Nominal value of input (used for scaling the states)", 44, 1.0, 0.0,0.0,0.0,0,2608)
DeclareState("boiler2WithControls.boi.valBoi.filter.x[1]", "Filter states", 0, \
0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("boiler2WithControls.boi.valBoi.filter.der(x[1])", \
"der(Filter states)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("boiler2WithControls.boi.valBoi.filter.x[2]", "Filter states", 1, \
0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("boiler2WithControls.boi.valBoi.filter.der(x[2])", \
"der(Filter states)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.ncr", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.nc0", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.na", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.nr", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.cr[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.cr[2]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.r[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.r[2]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.filter.uu[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.valBoi.filter.uu[2]", "", \
"boiler2WithControls.boi.valBoi.filter.x[1]", 1, 1, 0, 1024)
DeclareAlias2("boiler2WithControls.boi.valBoi.filter.uu[3]", "", \
"boiler2WithControls.boi.valBoi.filter.x[2]", 1, 1, 1, 1024)
DeclareParameter("boiler2WithControls.boi.valBoi.dpFixed_nominal", \
"Pressure drop of pipe and other resistances that are in series [Pa|Pa]", 45, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.valBoi.l", "Valve leakage, l=Kv(y=0)/Kv(y=1)",\
 46, 0.0001, 1E-010,1.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valBoi.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.valBoi.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valBoi.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.valBoi.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.valByp.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valByp.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -1E+060,100000.0,10.0,0,840)
DeclareAlias2("boiler2WithControls.boi.valByp.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareVariable("boiler2WithControls.boi.valByp.port_a.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("boiler2WithControls.boi.valByp.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.boi.valByp.port_a.m_flow", -1, 5, 150, 132)
DeclareVariable("boiler2WithControls.boi.valByp.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,300000.0,0,521)
DeclareVariable("boiler2WithControls.boi.valByp.port_b.h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("boiler2WithControls.boi.valByp.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 47, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.valByp.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 48,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.boi.valByp.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 49, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.valByp.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 10, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.boi.valByp.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "boiler2WithControls.boi.valByp.port_a.m_flow", 1, 5, 150, 0)
DeclareVariable("boiler2WithControls.boi.valByp.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("boiler2WithControls.boi.valByp.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valByp.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.homotopyInitialization", \
"= true, use homotopy method [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valByp.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.boi.valByp.m_flow_turbulent", \
"Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valByp.sta_default.p", \
"Absolute pressure of medium [Pa|bar]", 50, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valByp.sta_default.T", \
"Temperature of medium [K|degC]", 51, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("boiler2WithControls.boi.valByp.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.m_flow_nominal_pos", \
"Absolute value of nominal flow rate [kg/s]", 10, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.dp_nominal_pos", \
"Absolute value of nominal pressure [Pa|bar]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.CvData", "Selection of flow coefficient [:#(type=Buildings.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.boi.valByp.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.Av", "Av (metric) flow coefficient [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valByp.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 52, 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valByp.dpValve_nominal", \
"Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 100, 1E-060,1E+100,0.0,0,513)
DeclareParameter("boiler2WithControls.boi.valByp.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 53, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valByp.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.filteredOpening", \
"= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("boiler2WithControls.boi.valByp.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 54, 120, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valByp.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("boiler2WithControls.boi.valByp.y_start", "Initial value of output",\
 55, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valByp.y", "Actuator position (0: closed, 1: open)",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("boiler2WithControls.boi.valByp.y_actual", "Actual valve position",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.boi.valByp.y_filtered", "Filtered valve position in the range 0..1",\
 "boiler2WithControls.boi.valByp.y_actual", 1, 5, 175, 1024)
DeclareAlias2("boiler2WithControls.boi.valByp.filter.u", "Connector of Real input signal",\
 "boiler2WithControls.boi.valByp.y", 1, 5, 174, 1024)
DeclareAlias2("boiler2WithControls.boi.valByp.filter.y", "Connector of Real output signal",\
 "boiler2WithControls.boi.valByp.y_actual", 1, 5, 175, 1024)
DeclareVariable("boiler2WithControls.boi.valByp.filter.analogFilter", \
"Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.filterType", \
"Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.order", "Order of filter [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.f_cut", "Cut-off frequency [Hz]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.boi.valByp.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 56, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valByp.filter.A_ripple", \
"Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 57, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valByp.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 58, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valByp.filter.normalized", \
"= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 59, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.valByp.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.nx", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("boiler2WithControls.boi.valByp.filter.x_start[1]", \
"Initial or guess values of states", 60, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("boiler2WithControls.boi.valByp.filter.x_start[2]", \
"Initial or guess values of states", 61, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("boiler2WithControls.boi.valByp.filter.y_start", \
"Initial value of output", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.boi.valByp.filter.u_nominal", \
"Nominal value of input (used for scaling the states)", 62, 1.0, 0.0,0.0,0.0,0,2608)
DeclareState("boiler2WithControls.boi.valByp.filter.x[1]", "Filter states", 2, \
0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("boiler2WithControls.boi.valByp.filter.der(x[1])", \
"der(Filter states)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("boiler2WithControls.boi.valByp.filter.x[2]", "Filter states", 3, \
0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("boiler2WithControls.boi.valByp.filter.der(x[2])", \
"der(Filter states)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.valByp.filter.ncr", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.nc0", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.na", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.nr", "[:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.valByp.filter.cr[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.filter.cr[2]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.filter.r[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.filter.r[2]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.filter.uu[1]", "", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.valByp.filter.uu[2]", "", \
"boiler2WithControls.boi.valByp.filter.x[1]", 1, 1, 2, 1024)
DeclareAlias2("boiler2WithControls.boi.valByp.filter.uu[3]", "", \
"boiler2WithControls.boi.valByp.filter.x[2]", 1, 1, 3, 1024)
DeclareParameter("boiler2WithControls.boi.valByp.dpFixed_nominal", \
"Pressure drop of pipe and other resistances that are in series [Pa|Pa]", 63, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.valByp.l", "Valve leakage, l=Kv(y=0)/Kv(y=1)",\
 64, 0.0001, 1E-010,1.0,0.0,0,560)
DeclareVariable("boiler2WithControls.boi.valByp.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.valByp.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.valByp.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.valByp.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareAlias2("boiler2WithControls.boi.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.port_b1.m_flow", 1, 5, 251, 132)
DeclareVariable("boiler2WithControls.boi.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("boiler2WithControls.boi.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.port_b1.h_outflow", 1, 5, 253, 4)
DeclareVariable("boiler2WithControls.boi.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 10.0, -100000.0,100000.0,0.0,0,777)
DeclareAlias2("boiler2WithControls.boi.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareAlias2("boiler2WithControls.boi.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.port_a1.h_outflow", 1, 5, 256, 4)
DeclareVariable("boiler2WithControls.boi.boiCon", "Control singal for boiler", \
0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("boiler2WithControls.boi.valCon", "Control signal for valves in boiler loop",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareAlias2("boiler2WithControls.boi.add.u1", "Connector of Real input signal 1",\
 "boiler2WithControls.boi.valCon", 1, 5, 199, 0)
DeclareAlias2("boiler2WithControls.boi.add.u2", "Connector of Real input signal 2",\
 "boiler2WithControls.boi.const.k", 1, 7, 67, 0)
DeclareAlias2("boiler2WithControls.boi.add.y", "Connector of Real output signal",\
 "boiler2WithControls.boi.valByp.y", 1, 5, 174, 0)
DeclareParameter("boiler2WithControls.boi.add.k1", "Gain of upper input", 65, -1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.add.k2", "Gain of lower input", 66, 1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.boi.const.k", "Constant output value", 67,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.boi.const.y", "Connector of Real output signal",\
 "boiler2WithControls.boi.const.k", 1, 7, 67, 0)
DeclareAlias2("boiler2WithControls.bolCon.integerToReal.u", "Connector of Integer input signal [:#(type=Integer)]",\
 "StaVal.k", 1, 7, 120, 66)
DeclareVariable("boiler2WithControls.bolCon.integerToReal.y", "Connector of Real output signal [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.replicator.nout", "Number of outputs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("boiler2WithControls.bolCon.replicator.u", "Connector of Real input signal [1]",\
 "boiler2WithControls.bolCon.integerToReal.y", 1, 5, 200, 0)
DeclareAlias2("boiler2WithControls.bolCon.replicator.y[1]", "Connector of Real output signals [1]",\
 "boiler2WithControls.bolCon.integerToReal.y", 1, 5, 200, 0)
DeclareAlias2("boiler2WithControls.bolCon.replicator.y[2]", "Connector of Real output signals [1]",\
 "boiler2WithControls.bolCon.integerToReal.y", 1, 5, 200, 0)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("boiler2WithControls.bolCon.combiTable1D.u[1]", "Connector of Real input signals [1]",\
 "boiler2WithControls.bolCon.integerToReal.y", 1, 5, 200, 0)
DeclareAlias2("boiler2WithControls.bolCon.combiTable1D.u[2]", "Connector of Real input signals [1]",\
 "boiler2WithControls.bolCon.integerToReal.y", 1, 5, 200, 0)
DeclareAlias2("boiler2WithControls.bolCon.combiTable1D.y[1]", "Connector of Real output signals",\
 "boiler2WithControls.boi.valCon", 1, 5, 199, 0)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.y[2]", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.tableOnFile", \
"= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[1, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 68, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[1, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 69, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[1, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 70, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[2, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 71, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[2, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 72, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[2, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 73, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[3, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 74, 3, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[3, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 75, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[3, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 76, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[4, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 77, 4, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[4, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 78, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[4, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 79, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[5, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 80, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[5, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 81, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[5, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 82, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[6, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 83, 6, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[6, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 84, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[6, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 85, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[7, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 86, 7, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[7, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 87, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.table[7, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 88, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.combiTable1D.verboseRead", \
"= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 89, true, 0.0,0.0,0.0,0,562)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.columns[1]", \
"Columns of table to be interpolated [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.columns[2]", \
"Columns of table to be interpolated [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.smoothness", \
"Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.tableID.id", \
"[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.bolCon.combiTable1D.tableOnFileRead", \
"= 1, if table was successfully read from file", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("boiler2WithControls.bolCon.TSetBoi.k", "Constant output value",\
 90, 373.15, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.bolCon.TSetBoi.y", "Connector of Real output signal",\
 "boiler2WithControls.bolCon.TSetBoi.k", 1, 7, 90, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.u_s", "Connector of setpoint input signal",\
 "boiler2WithControls.bolCon.TSetBoi.k", 1, 7, 90, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.u_m", "Connector of measurement input signal",\
 "const.k", 1, 7, 119, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.y", "Connector of actuator output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.bolCon.conPID.controlError", \
"Control error (set point - measurement)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.controllerType", \
"Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]", 4, 1.0,\
4.0,0.0,0,517)
DeclareParameter("boiler2WithControls.bolCon.conPID.k", "Gain of controller [1]",\
 91, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.Ti", "Time constant of Integrator block [s]",\
 92, 0.5, 1E-060,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.Td", "Time constant of Derivative block [s]",\
 93, 0.1, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.yMax", "Upper limit of output",\
 94, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.yMin", "Lower limit of output",\
 95, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.wp", "Set-point weight for Proportional block (0..1)",\
 96, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.wd", "Set-point weight for Derivative block (0..1)",\
 97, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 98, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.Nd", "The higher Nd, the more ideal the derivative block",\
 99, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("boiler2WithControls.bolCon.conPID.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.conPID.limitsAtInit", \
"= false, if limits are ignored during initialization [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareParameter("boiler2WithControls.bolCon.conPID.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 100, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.xd_start", "Initial or guess value for state of derivative block",\
 101, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.y_start", "Initial value of output",\
 102, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.bolCon.conPID.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.bolCon.conPID.unitTime", "[s]", 1, 0.0,0.0,\
0.0,0,1537)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addP.u1", "Connector of Real input signal 1",\
 "boiler2WithControls.bolCon.TSetBoi.k", 1, 7, 90, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addP.u2", "Connector of Real input signal 2",\
 "const.k", 1, 7, 119, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.addP.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.addP.k1", "Gain of upper input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.addP.k2", "Gain of lower input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("boiler2WithControls.bolCon.conPID.P.k", "Gain value multiplied with input signal [1]",\
 103, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.bolCon.conPID.P.u", "Input signal connector",\
 "boiler2WithControls.bolCon.conPID.addP.y", 1, 5, 217, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.P.y", "Output signal connector",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.gainPID.u", "Input signal connector",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.bolCon.conPID.gainPID.y", "Output signal connector",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("boiler2WithControls.bolCon.conPID.addPID.k1", "Gain of upper input",\
 104, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.addPID.k2", "Gain of middle input",\
 105, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.addPID.k3", "Gain of lower input",\
 106, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addPID.u1", "Connector 1 of Real input signals",\
 "boiler2WithControls.bolCon.conPID.P.y", 1, 5, 220, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.addPID.u2", "Connector 2 of Real input signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addPID.u3", "Connector 3 of Real input signals",\
 "boiler2WithControls.bolCon.conPID.I.y", 1, 1, 6, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addPID.y", "Connector of Real output signals",\
 "boiler2WithControls.bolCon.conPID.gainPID.u", 1, 5, 222, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.limiter.uMax", \
"Upper limits of input signals", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.limiter.uMin", \
"Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.limiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("boiler2WithControls.bolCon.conPID.limiter.limitsAtInit", \
"= false, if limits are ignored during initialization (i.e., y=u) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.bolCon.conPID.limiter.u", "Connector of Real input signal",\
 "boiler2WithControls.bolCon.conPID.gainPID.y", 1, 5, 223, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.limiter.y", "Connector of Real output signal",\
 "boiler2WithControls.bolCon.conPID.y", 1, 5, 210, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.with_I", "[:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("boiler2WithControls.bolCon.conPID.with_D", "[:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareParameter("boiler2WithControls.bolCon.conPID.reverseAction", \
"Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 107, false, 0.0,0.0,0.0,0,562)
DeclareVariable("boiler2WithControls.bolCon.conPID.revAct", "", 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("boiler2WithControls.bolCon.product.u1", "Connector of Real input signal 1",\
 "boiler2WithControls.bolCon.combiTable1D.y[2]", 1, 5, 203, 0)
DeclareAlias2("boiler2WithControls.bolCon.product.u2", "Connector of Real input signal 2",\
 "boiler2WithControls.bolCon.conPID.y", 1, 5, 210, 0)
DeclareAlias2("boiler2WithControls.bolCon.product.y", "Connector of Real output signal",\
 "boiler2WithControls.boi.boiCon", 1, 5, 198, 0)
DeclareAlias2("boiler2WithControls.bolCon.BoiCtr", "Connector of Real output signal",\
 "boiler2WithControls.boi.boiCon", 1, 5, 198, 0)
DeclareAlias2("boiler2WithControls.bolCon.Val4Ctr", "Connector of Real output signals",\
 "boiler2WithControls.boi.valCon", 1, 5, 199, 0)
DeclareAlias2("boiler2WithControls.bolCon.TMea", "Measured temperture of water leaving the heat pump",\
 "const.k", 1, 7, 119, 0)
DeclareAlias2("boiler2WithControls.bolCon.sta", "State of the system sent from superviory control [:#(type=Integer)]",\
 "StaVal.k", 1, 7, 120, 66)
DeclareVariable("boiler2WithControls.senMasFlo.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boiler2WithControls.senMasFlo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 10.0, -1E+060,100000.0,0.0,0,777)
DeclareAlias2("boiler2WithControls.senMasFlo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareAlias2("boiler2WithControls.senMasFlo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.port_a1.h_outflow", 1, 5, 256, 4)
DeclareVariable("boiler2WithControls.senMasFlo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -10.0, -100000.0,1E+060,0.0,0,777)
DeclareAlias2("boiler2WithControls.senMasFlo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareAlias2("boiler2WithControls.senMasFlo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boundary.ports[1].h_outflow", 1, 5, 268, 4)
DeclareParameter("boiler2WithControls.senMasFlo.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 108, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.senMasFlo.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 109,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.senMasFlo.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 110, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.senMasFlo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.senMasFlo.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.senMasFlo.m_flow", "Mass flow rate from port_a to port_b [kg/s]",\
 10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.BoiTSen.allowFlowReversal", \
"= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("boiler2WithControls.BoiTSen.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.port_b1.m_flow", -1, 5, 251, 132)
DeclareVariable("boiler2WithControls.BoiTSen.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("boiler2WithControls.BoiTSen.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "bou1.ports[1].h_outflow", 1, 5, 290, 4)
DeclareAlias2("boiler2WithControls.BoiTSen.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.port_b1.m_flow", 1, 5, 251, 132)
DeclareVariable("boiler2WithControls.BoiTSen.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("boiler2WithControls.BoiTSen.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.port_b1.h_outflow", 1, 5, 253, 4)
DeclareParameter("boiler2WithControls.BoiTSen.port_a_exposesState", \
"= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]", 111, \
false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.BoiTSen.port_b_exposesState", \
"= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]", 112,\
 false, 0.0,0.0,0.0,0,2610)
DeclareParameter("boiler2WithControls.BoiTSen.showDesignFlowDirection", \
"= false to hide the arrow in the model icon [:#(type=Boolean)]", 113, true, \
0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.BoiTSen.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 10, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.BoiTSen.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.BoiTSen.tau", "Time constant at nominal flow rate [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.BoiTSen.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.BoiTSen.k", "Gain to take flow rate into account for sensor time constant [1]",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.BoiTSen.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("boiler2WithControls.BoiTSen.mNor_flow", "Normalized mass flow rate [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("boiler2WithControls.BoiTSen.T", "Temperature of the passing fluid [K|degC]",\
 4, 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("boiler2WithControls.BoiTSen.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("boiler2WithControls.BoiTSen.T_start", "Initial or guess value of output (= state) [K|degC]",\
 114, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("boiler2WithControls.BoiTSen.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("boiler2WithControls.BoiTSen.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 300, 1.0,10000.0,300.0,0,2560)
DeclareVariable("boiler2WithControls.BoiTSen.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boiler2WithControls.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,776)
DeclareVariable("boiler2WithControls.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("boiler2WithControls.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("boiler2WithControls.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 10, -100000.0,100000.0,0.0,0,777)
DeclareVariable("boiler2WithControls.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("boiler2WithControls.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("boiler2WithControls.Sta", "States commanded by the supervisory control [:#(type=Integer)]",\
 "StaVal.k", 1, 7, 120, 66)
DeclareAlias2("boiler2WithControls.HPTSen", "Heat pump temperature sensor signal",\
 "const.k", 1, 7, 119, 0)
DeclareAlias2("boiler2WithControls.TBoi", "Signal of the output temperature after it has gone through the boiler [K]",\
 "boiler2WithControls.BoiTSen.T", 1, 1, 4, 0)
DeclareVariable("boundary.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("boundary.medium.p", "Absolute pressure of medium [Pa|bar]", \
"boiler2WithControls.port_a1.p", 1, 5, 255, 0)
DeclareAlias2("boundary.medium.h", "Specific enthalpy of medium [J/kg]", \
"boundary.ports[1].h_outflow", 1, 5, 268, 0)
DeclareVariable("boundary.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586,\
 0.0,100000.0,1.0,0,513)
DeclareAlias2("boundary.medium.T", "Temperature of medium [K|degC]", \
"boundary.T", 1, 7, 115, 0)
DeclareVariable("boundary.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boundary.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("boundary.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("boundary.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("boundary.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 0)
DeclareAlias2("boundary.medium.state.T", "Temperature of medium [K|degC]", \
"boundary.T", 1, 7, 115, 0)
DeclareVariable("boundary.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boundary.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 -10.0, -1E+060,1E+060,0.0,0,777)
DeclareAlias2("boundary.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "boiler2WithControls.port_a1.p", 1, 5, 255, 4)
DeclareVariable("boundary.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("boundary.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("boundary.use_m_flow_in", "Get the mass flow rate from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 10, 0.0,0.0,0.0,0,513)
DeclareParameter("boundary.T", "Fixed value of temperature [K|degC]", 115, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("boundary.X[1]", "Fixed value of composition [kg/kg]", 116, 1.0,\
 0.0,1.0,0.1,0,560)
DeclareVariable("boundary.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 10.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("boundary.T_in_internal", "Needed to connect to conditional connector [K]",\
 "boundary.T", 1, 7, 115, 1024)
DeclareVariable("boundary.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("bou1.nPorts", "Number of ports [:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("bou1.medium.p", "Absolute pressure of medium [Pa|bar]", 100.0, \
0.0,1E+100,100000.0,0,513)
DeclareAlias2("bou1.medium.h", "Specific enthalpy of medium [J/kg]", \
"bou1.ports[1].h_outflow", 1, 5, 290, 0)
DeclareVariable("bou1.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareAlias2("bou1.medium.T", "Temperature of medium [K|degC]", "bou1.T", 1, 7,\
 117, 0)
DeclareVariable("bou1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("bou1.medium.u", "Specific internal energy of medium [J/kg]", \
0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("bou1.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("bou1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("bou1.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
100.0, 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("bou1.medium.state.T", "Temperature of medium [K|degC]", "bou1.T", 1,\
 7, 117, 0)
DeclareVariable("bou1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("bou1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("bou1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("bou1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareAlias2("bou1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "boiler2WithControls.port_b1.m_flow", -1, 5, 251, 132)
DeclareVariable("bou1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("bou1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("bou1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("bou1.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("bou1.p", "Fixed value of pressure [Pa|bar]", 100, 0.0,\
100000000.0,100000.0,0,513)
DeclareParameter("bou1.T", "Fixed value of temperature [K|degC]", 117, 293.15, \
1.0,10000.0,300.0,0,560)
DeclareParameter("bou1.X[1]", "Fixed value of composition [kg/kg]", 118, 1.0, \
0.0,1.0,0.1,0,560)
DeclareVariable("bou1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 100.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("bou1.T_in_internal", "Needed to connect to conditional connector [K]",\
 "bou1.T", 1, 7, 117, 1024)
DeclareVariable("bou1.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareOutput("TBoi1", "Signal of the output temperature after it has gone through the boiler [K]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("const.k", "Constant output value", 119, 295.37, 0.0,0.0,0.0,0,560)
DeclareAlias2("const.y", "Connector of Real output signal", "const.k", 1, 7, 119,\
 0)
DeclareParameter("StaVal.k", "Constant output value [:#(type=Integer)]", 120, 1,\
 0.0,0.0,0.0,0,564)
DeclareAlias2("StaVal.y", "Connector of Integer output signal [:#(type=Integer)]",\
 "StaVal.k", 1, 7, 120, 66)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.energyDynamics", \
"Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.massDynamics", \
"Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, 1.0,\
4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.substanceDynamics", \
"Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]", 1, \
1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.traceDynamics", \
"Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.p_start", \
"Start value of pressure [Pa|bar]", 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.T_start", \
"Start value of temperature [K|degC]", 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.X_start[1]", \
"Start value of mass fractions m_i/m [kg/kg]", 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.nPorts", \
"Number of ports [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.ports[1].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_a.m_flow", 1, 5, 17, 1156)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.ports[1].p", \
"Thermodynamic pressure in the connection point [Pa|bar]", 100.0, 0.0,\
100000000.0,100000.0,0,2569)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.ports[1].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 1028)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.ports[2].m_flow", \
"Mass flow rate from the connection point into the component [kg/s]", \
"boiler2WithControls.boi.boi.port_b.m_flow", 1, 5, 21, 1156)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.ports[2].p", \
"Thermodynamic pressure in the connection point [Pa|bar]", 100.0, 0.0,\
100000000.0,100000.0,0,2569)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.ports[2].h_outflow", \
"Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 1028)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.p", \
"Absolute pressure of medium [Pa|bar]", 100, 0.0,1E+100,300000.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.medium.h", \
"Specific enthalpy of medium [J/kg]", "boiler2WithControls.boi.boi.port_a.h_outflow", 1,\
 5, 19, 1024)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.d", \
"Density of medium [kg/m3|g/cm3]", 995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("boiler2WithControls.boi.boi.vol.dynBal.medium.T", "Temperature of medium [K|degC]",\
 5, 293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("boiler2WithControls.boi.boi.vol.dynBal.medium.der(T)", \
"der(Temperature of medium) [K/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.X[1]", \
"Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]", 1.0, 0.0,1.0,\
0.1,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.u", \
"Specific internal energy of medium [J/kg]", 0.0, -100000000.0,100000000.0,\
1000000.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.der(u)", \
"der(Specific internal energy of medium) [m2/s3]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.R", \
"Gas constant (of mixture if applicable) [J/(kg.K)]", 0, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.MM", \
"Molar mass (of mixture or single fluid) [kg/mol]", 0.018015268, 0.001,0.25,\
0.032,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.state.p", \
"Absolute pressure of medium [Pa|bar]", 100.0, 0.0,100000000.0,100000.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.medium.state.T", \
"Temperature of medium [K|degC]", "boiler2WithControls.boi.boi.vol.dynBal.medium.T", 1,\
 1, 5, 1024)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.preferredMediumStates",\
 "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.standardOrderComponents",\
 "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.T_degC", \
"Temperature of medium in [degC] [degC;]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.medium.p_bar", \
"Absolute pressure of medium in [bar] [bar]", 0.001, 0.0,0.0,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.U", "Internal energy of fluid [J]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.der(U)", \
"der(Internal energy of fluid) [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.m", "Mass of fluid [kg]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.der(m)", \
"der(Mass of fluid) [kg/s]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 "boiler2WithControls.boi.boi.vol.masExc.k", -1, 7, 13, 1024)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.Hb_flow", \
"Enthalpy flow across boundaries or energy source/sink [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.fluidVolume", \
"Volume [m3]", "boiler2WithControls.boi.boi.vol.V", 1, 5, 50, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 "boiler2WithControls.boi.boi.vol.heatPort.Q_flow", 1, 5, 54, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.mWat_flow", \
"Moisture mass flow rate added to the medium [kg/s]", "boiler2WithControls.boi.boi.vol.masExc.k", 1,\
 7, 13, 1024)
DeclareAlias2("boiler2WithControls.boi.boi.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "boiler2WithControls.boi.boi.port_a.h_outflow", 1, 5, 19, 1024)
DeclareParameter("boiler2WithControls.boi.boi.vol.dynBal.initialize_p", \
"= true to set up initial equations for pressure [:#(type=Boolean)]", 121, false,\
 0.0,0.0,0.0,0,2610)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.ports_H_flow[1]", "[W]",\
 0.0, -100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.ports_H_flow[2]", "[W]",\
 0.0, -100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.rho_nominal", \
"Density, used to compute fluid mass [kg/m3|g/cm3]", 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("boiler2WithControls.boi.boi.vol.dynBal.hStart", \
"Start value for specific enthalpy [J/kg]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addD.u1", "Connector of Real input signal 1",\
 "boiler2WithControls.bolCon.TSetBoi.k", 1, 7, 90, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addD.u2", "Connector of Real input signal 2",\
 "const.k", 1, 7, 119, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.addD.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.addD.k1", "Gain of upper input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.addD.k2", "Gain of lower input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.I.k", "Integrator gain [1]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.conPID.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.I.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("boiler2WithControls.bolCon.conPID.I.y", "Connector of Real output signal",\
 6, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("boiler2WithControls.bolCon.conPID.I.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.bolCon.conPID.D.k", "Gains [1]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-060, 1E-060,1E+100,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("boiler2WithControls.bolCon.conPID.D.x_start", "Initial or guess value of state",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("boiler2WithControls.bolCon.conPID.D.y_start", "Initial value of output (= state)",\
 122, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.bolCon.conPID.D.u", "Connector of Real input signal",\
 "boiler2WithControls.bolCon.conPID.addD.y", 1, 5, 330, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.D.y", "Connector of Real output signal",\
 "boiler2WithControls.bolCon.conPID.addPID.u2", 1, 5, 224, 0)
DeclareState("boiler2WithControls.bolCon.conPID.D.x", "State of block", 7, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("boiler2WithControls.bolCon.conPID.D.der(x)", "der(State of block)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boiler2WithControls.bolCon.conPID.D.zeroGain", "[:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("boiler2WithControls.bolCon.conPID.addI.k1", "Gain of upper input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("boiler2WithControls.bolCon.conPID.addI.k2", "Gain of middle input",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("boiler2WithControls.bolCon.conPID.addI.k3", "Gain of lower input",\
 123, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addI.u1", "Connector 1 of Real input signals",\
 "boiler2WithControls.bolCon.TSetBoi.k", 1, 7, 90, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addI.u2", "Connector 2 of Real input signals",\
 "const.k", 1, 7, 119, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.addI.u3", "Connector 3 of Real input signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addI.y", "Connector of Real output signals",\
 "boiler2WithControls.bolCon.conPID.I.u", 1, 5, 336, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addSat.u1", "Connector of Real input signal 1",\
 "boiler2WithControls.bolCon.conPID.y", 1, 5, 210, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.addSat.u2", "Connector of Real input signal 2",\
 "boiler2WithControls.bolCon.conPID.gainPID.y", 1, 5, 223, 0)
DeclareVariable("boiler2WithControls.bolCon.conPID.addSat.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("boiler2WithControls.bolCon.conPID.addSat.k1", "Gain of upper input",\
 124, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("boiler2WithControls.bolCon.conPID.addSat.k2", "Gain of lower input",\
 125, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("boiler2WithControls.bolCon.conPID.gainTrack.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("boiler2WithControls.bolCon.conPID.gainTrack.u", "Input signal connector",\
 "boiler2WithControls.bolCon.conPID.addSat.y", 1, 5, 345, 0)
DeclareAlias2("boiler2WithControls.bolCon.conPID.gainTrack.y", "Output signal connector",\
 "boiler2WithControls.bolCon.conPID.addI.u3", 1, 5, 344, 0)
EndNonAlias(0)
#define NX_    8
#define NX2_   3
#define NU_    0
#define NY_    1
#define NW_    347
#define NP_    126
#define NPS_   0
#define MAXAuxStr_   3
#define MAXAuxStrLen_   500
#define NHash1_ 1160451696
#define NHash2_ 20201346
#define NHash3_ 0
#define NI_    0
#define NRelF_ 5
#define NRel_  5
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    132
#define SizePre_ 0
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 22
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 48
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[2];
if (HReject) W_[150]=initStore[0]; else initStore[0]=W_[150];
}
StartDataBlock
StartEqBlock
DoRemember_(W_[18], 300000.0, 0);
DoRemember_(W_[150], 0, 1);
DoRemember_(F_[5], 0.0, 2);
EndEqBlock
EndDataBlock
  BreakSectionStart(3);
   /* Linear system of equations to solve. */
  W_[150] = 0;
  SolveScalarLinearParametric((-10.0)-0.1*(W_[119]+W_[165]),"(-10.0)-0.1*(boiler2WithControls.boi.valBoi.dp_nominal_pos+boiler2WithControls.boi.valByp.dp_nominal_pos)",
     (-100.0)-W_[119],"(-100.0)-boiler2WithControls.boi.valBoi.dp_nominal_pos", 
    W_[150],"boiler2WithControls.boi.valByp.port_a.m_flow");
  W_[17] = 10.0-W_[150];
  W_[69] = 10.0*W_[17];
  W_[18] = 100.0+W_[69];
  W_[111] = 0.1*W_[119]*W_[17];
  W_[255] = W_[111]+W_[18];
  W_[157] = W_[255]-100.0;
   /* End of Equation Block */ 

  BreakSectionEnd()
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(6);
BreakSectionFunctionCallNew(7);
BreakSectionFunctionCallNew(8);
BreakSectionFunctionEnd()
